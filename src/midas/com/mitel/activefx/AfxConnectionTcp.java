/* Generated by Together */

package com.mitel.activefx;

import com.mitel.miutil.MiSystem;
import java.net.SocketException;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import com.mitel.mifsm.FsmEvent;
import com.mitel.miutil.MiExceptionUtil;
import com.mitel.miutil.MiLogMsg.Category;
import java.nio.channels.SelectableChannel;
import java.io.IOException;


/**
 * An AFX connection for handling TCP/IP channels
 */
public class AfxConnectionTcp extends AfxConnection implements ReactorEventHandler
{
	private static volatile int gNumMsgsWrittenForAllChannels;
	private static volatile long gFirstWriteTs;
	private static volatile long gLastWriteTs;
	private volatile int numMsgsWrittenForThisChannel;
	
	/**
	 * Creates a new connection instance
	 * @param domain The AFX domain driving the state of this connection.
	 */
	public AfxConnectionTcp(AfxDomain domain)
	{
		super(domain);
	}	

	@Override
	public int getConnectionType()
	{
		return AfxConnection.AFX_CONNECTION_TCP;
	}

	@Override
	public synchronized boolean isOpen()
	{
		return m_Channel != null ? this.m_Channel.socket().isOutputShutdown() : false;
	}	

	@Override
	public void onAccept()
	{
		m_Domain.deregisterHandler(this, SelectionKey.OP_ACCEPT);
	}

	/**
	 * Retrieves the application-wide message write rate
	 * @return The number of messages written per hour since the start of the application.
	 */
	public static int getMsgsRatePerHour() {
		long delta = (gLastWriteTs - gFirstWriteTs);
		if(delta > 0) {
			return (int)(((float)gNumMsgsWrittenForAllChannels / (float)delta) * 1000.0 * 3600.0);
		}
		return 0;
	}
	
	@Override
	public synchronized void onWrite()
	{
		if(!m_ReactorWriteEnabled || m_Channel == null)
		{
			// This does happen from time to time
			return;
		}
		
		try
		{
			if(null != m_WriteBuffer)
			{
				if(-1 < m_Channel.write(m_WriteBuffer))
				{
					if(m_WriteBuffer.remaining()==0)
					{
						gLastWriteTs = System.currentTimeMillis();
						++gNumMsgsWrittenForAllChannels;
						++numMsgsWrittenForThisChannel;
						
						// Wrote the entire buffer, don't need write event any more ...
						disableReactorWrite();

						// ... null out the write buffer ...
						m_WriteBuffer = null;
						
						// ... and trigger the transition on event WRITE_COMPLETE
						m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.WRITE_COMPLETE, this), true);
					}
				}
				else
				{
					MiSystem.logError(Category.DESIGN, "Write on " + this + " failed on " + m_Channel);
				
					// Write failed, don't need write event any more ...
					disableReactorWrite();
					
					// ... null out the write buffer ...
					m_WriteBuffer = null;
					
					// ... and trigger the transition on event WRITE_FAILURE
					m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.WRITE_FAILURE, this), true);
				}
			}
			else
			{
				// No buffer, don't need write event any more ...
				MiSystem.logError(Category.DESIGN, "No write buffer");
				
				disableReactorWrite();
			}
		}
		catch(Exception e)
		{
			MiSystem.logError(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
			
			try
			{
				// Write failed, don't need write event any more ...
				disableReactorWrite();

				// ... null out the write buffer ...
				m_WriteBuffer = null;
				
				// ... And trigger the transition on event FAILURE
				m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.WRITE_FAILURE, this), true);
			}
			catch(Exception e2)
			{
			}
		}
	}

	@Override
	public synchronized void onConnect()
	{
		String cause;
		
		if(m_Channel == null)
		{
			MiSystem.logError(Category.DESIGN, "Connect failed - channel is not open");
			cause = "Channel is not open.";
		}
		else if(m_Channel.isConnectionPending())
		{
			try
			{
				if(m_Channel.finishConnect())
				{
					if(MiSystem.diagnosticEnabled()) {
						MiSystem.logInfo(Category.DESIGN, this + " finished connecting");
					}
					m_Domain.deregisterHandler(this, SelectionKey.OP_CONNECT);
					m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_COMPLETE, this), true);
						
					return;
				}
				else
				{
					if(MiSystem.diagnosticEnabled()) {
						MiSystem.logInfo(Category.DESIGN, this + " still waiting for connect completion");
					}
					// Connection not yet finish (this is a non-blocking channel), keep checking
					return;
				}
			}
			catch(IOException e)
			{
				if(MiSystem.diagnosticEnabled())
				{
					MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
				}
				cause = e.getMessage();
			}
		}
		else if(!m_Channel.isConnected())
		{
			cause = m_Channel + " not in connect pending state.";
			
			if(MiSystem.diagnosticEnabled())
			{
				MiSystem.logInfo(Category.DESIGN, cause);
			}
		}
		else
		{
			if(MiSystem.diagnosticEnabled()) {
				MiSystem.logInfo(Category.DESIGN, this + " already connected, go");
			}
			// Channel is connected
			m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_COMPLETE, this), true);
			return;
		}
		
		m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_FAILURE, this, cause), true);
	}

	@Override
	public synchronized void onDisconnect()
	{
		m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.CLOSE, this), false);
	}

	@Override
	public synchronized void onRead()
	{
		try
		{
			if((m_ReadBuffer != null)&&(m_ReadBuffer.hasRemaining()))
			{
				if(null != m_Channel)
				{
					if(-1 < m_Channel.read(m_ReadBuffer))
					{
						if(m_ReadBuffer.remaining()==0)
						{
							// ... And trigger the transition on event READ_COMPLETE
							m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.READ_COMPLETE, this), true);
						}
					}
					else
					{
						// Probably end-of-stream, i.e. the other side closed its writer ...
						// ... trigger the transition on event READ_FAILURE
						throw new IOException("Read on " + this + " returned -1, probably end of stream.");
					}
				}
				else
					throw new IOException("Channel is NULL, probably in the middle of shutting down");
			}
			else
			{
				// Not ready to accept more read event, stop the reading process ...
				disableReactorRead();
			}
		}
		catch(java.io.IOException e)
		{
			MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
			
			// Read failed, stop the reading process ...
			disableReactorRead();
			m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.READ_FAILURE, this), true);
		}
	}

	@Override
	public int getReceiveBufferSize()
	{
		try
		{
			return m_Channel.socket().getReceiveBufferSize();
		}
		catch(SocketException ex)
		{
			MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(ex));
		}
		catch(RuntimeException e)
		{
			MiSystem.logError(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
		}
		return -1;
	}

	@Override
	public int getSendBufferSize()
	{
		try
		{
			return m_Channel.socket().getSendBufferSize();
		}
		catch(SocketException ex)
		{
			MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(ex));
		}
		catch(RuntimeException e)
		{
			MiSystem.logError(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
		}
		return -1;
	}

	@Override
	public void setReceiveBufferSize(int newSize)
	{
		try
		{
			m_Channel.socket().setReceiveBufferSize(newSize);
		}
		catch(SocketException ex)
		{
			MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(ex));
		}
		catch(RuntimeException e)
		{
			MiSystem.logError(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
		}
	}

	@Override
	public void setSendBufferSize(int newSize)
	{
		try
		{
			m_Channel.socket().setSendBufferSize(newSize);
		}
		catch(SocketException ex)
		{
			MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(ex));
		}
		catch(RuntimeException e)
		{
			MiSystem.logError(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
		}
	}

	@Override
	public SelectableChannel getHandle()
	{
		return m_Channel;
	}

	@Override
	public String toString()
	{
		return "{channel:" + (m_Channel != null ? m_Channel.toString() : "null") + ", currentState:" + getCurrentState() + ", currentInterest:" + m_Domain.getInterestOps(this) + ", currentReady:" + m_Domain.getReadyOps(this) + ", numMsgsWritten:" + numMsgsWrittenForThisChannel + "}";
	}

	@Override
	public void handleHandshake(FsmEvent evt)
	{
		MiSystem.logInfo(Category.DESIGN, "Don't handle this event in this class");
	}

	@Override
	public void abortHandshake(FsmEvent evt)
	{
		MiSystem.logInfo(Category.DESIGN, "Don't handle this event in this class");
	}

	@Override
	@SuppressWarnings("NestedAssignment")
	public synchronized void initiateOpen(FsmEvent evt)
	{
		AfxFsmEvent afxEvent = (AfxFsmEvent)evt;
		try
		{
			m_ConnectionventHandler = afxEvent.getEventHandler();

			// Close any existing channel
			if(m_Channel != null)
			{
				m_Channel.close();
			}

			if(null == (m_Channel = (SocketChannel)afxEvent.getChannel()))
			{
				m_Channel = SocketChannel.open();

				m_Channel.configureBlocking(false);

				if(m_Channel.connect(new java.net.InetSocketAddress(afxEvent.getIpAddr(), afxEvent.getIpPort())))
				{
					MiSystem.logWarning(Category.DESIGN, "Unexpected non-blocking connect returning true");
				}
			}
			else
			{
				m_Channel.configureBlocking(false);
			}
			
			// Tells reactor to notify of connect events
			m_Domain.registerHandler(this, SelectionKey.OP_CONNECT);
		}
		catch(Exception e)
		{
			MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
			try
			{
				m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_FAILURE, 
					this, e.getMessage()), true);
			}
			catch(Exception e2)
			{
			}
		}
	}

	@Override
	public synchronized void initiateClose(FsmEvent evt)
	{
		if(m_Domain == null)
			return;
		
		m_Domain.removeHandler(this);
		if(m_Channel != null)
		{
			try
			{
				m_Channel.close();
			}
			catch(Exception e)
			{
				MiSystem.logError(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
			}
			m_Channel = null;

			m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.CLOSE_COMPLETE, this), true);

			if(m_ConnectionventHandler != null)
				m_ConnectionventHandler.closed();
		}
	}

	@Override
	public void initiateRead(FsmEvent evt)
	{
		// Tells the reactor to notify me of read events
		enableReactorRead();
	}

	@Override
	public void initiateWrite(FsmEvent evt)
	{
		// Tells reactor to notify of write events
		enableReactorWrite();
		if(gFirstWriteTs == 0) {
			gFirstWriteTs = System.currentTimeMillis();
		}
	}

	@Override
	public synchronized void initiateConnect(FsmEvent evt)
	{
		AfxFsmEvent afxEvent = (AfxFsmEvent)evt;
		if ( m_ConnectionventHandler == null ) {
		   m_ConnectionventHandler = afxEvent.getEventHandler() ;
		}
	   m_Channel = (SocketChannel)afxEvent.getChannel();
	   if(m_Channel.isConnected()) {
		   onConnect();
	   } else {
		   enableReactorConnect() ;
	   }
	}

	@Override
	public synchronized void openComplete(FsmEvent evt)
	{
		if(m_ConnectionventHandler != null)
			m_ConnectionventHandler.openCompleted();
	}

	@Override
	public synchronized void openFailed(FsmEvent evt)
	{
		AfxFsmEvent afxEvt = (AfxFsmEvent)evt;
		
		if(m_ConnectionventHandler != null)
			m_ConnectionventHandler.openFailed(afxEvt != null ? afxEvt.getCause() : "unknown");

		// No more open related event will come from this connection
		m_ConnectionventHandler = null;
	}

	@Override
	public synchronized void readComplete(FsmEvent evt)
	{
		if(m_ReadEventHandler != null)
		{
			m_ReadBuffer.flip();
			m_ReadEventHandler.readCompleted(m_ReadBuffer);
		}
		
		m_ReadBuffer = null;
	}

	@Override
	public synchronized void readFailed(FsmEvent evt)
	{
		if(m_ReadEventHandler != null)
			m_ReadEventHandler.readFailed();
	}

	@Override
	public synchronized void writeComplete(FsmEvent evt)
	{
		if(null != m_WriteEventHandler)
			m_WriteEventHandler.writeCompleted();
	}

	@Override
	public synchronized void writeFailed(FsmEvent evt)
	{
		if(null != m_WriteEventHandler)
			m_WriteEventHandler.writeFailed();
	}

	@Override
	public synchronized void readWriteFailed(FsmEvent evt)
	{
		if(m_ReadEventHandler != null)
			m_ReadEventHandler.readFailed();

		if(null != m_WriteEventHandler)
			m_WriteEventHandler.writeFailed();
	}

	protected synchronized void disableReactorRead()
	{
		if(m_ReactorReadEnabled)
		{
			m_Domain.deregisterHandler(this, SelectionKey.OP_READ);
			m_ReactorReadEnabled = false;
		}
	}
	
	protected synchronized void disableReactorWrite()
	{
		if(m_ReactorWriteEnabled)
		{
			m_Domain.deregisterHandler(this, SelectionKey.OP_WRITE);
			m_ReactorWriteEnabled = false;
		}
	}
	
	protected synchronized void disableReactorConnect() 
	{
		if(m_ReactorConnectEnabled)
		{
			m_Domain.deregisterHandler( this, SelectionKey.OP_CONNECT ) ;
			m_ReactorConnectEnabled = false ;
		}
	}
	
	protected synchronized void enableReactorRead()
	{
		if(!m_ReactorReadEnabled)
		{
			m_Domain.registerHandler(this, SelectionKey.OP_READ);
			m_ReactorReadEnabled = true;
		}
	}

	protected synchronized void enableReactorWrite()
	{
		if(!m_ReactorWriteEnabled)
		{
			m_Domain.registerHandler(this, SelectionKey.OP_WRITE);
			m_ReactorWriteEnabled = true;
		} else {
			MiSystem.logWarning(Category.DESIGN, "Already write enabled");
		}
	}

	/**
	 * Enables the reactor connect event. Not thread-safe
	 */
	protected void enableReactorConnect()
	{
		if(!m_ReactorConnectEnabled)
		{
			m_Domain.registerHandler( this, SelectionKey.OP_CONNECT ) ;
			m_ReactorConnectEnabled = true ;
		}
	}	

	@SuppressWarnings("ProtectedField")
	protected SocketChannel m_Channel = null;

	/** @link dependency */
    /*# AfxFsmEvent lnkAfxFsmEvent; */
	@SuppressWarnings("ProtectedField")
	protected boolean m_ReactorReadEnabled;
	@SuppressWarnings("ProtectedField")
	protected boolean m_ReactorWriteEnabled;
	@SuppressWarnings("ProtectedField")
	protected boolean m_ReactorConnectEnabled;	
}
