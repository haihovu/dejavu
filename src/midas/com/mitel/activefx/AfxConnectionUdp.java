/* Generated by Together */

package com.mitel.activefx;

import com.mitel.miutil.MiSystem;
import java.net.*;
import java.nio.channels.SelectionKey;
import com.mitel.mifsm.FsmEvent;
import java.nio.channels.SelectableChannel;
import com.mitel.mifsm.FsmContext;
import com.mitel.miutil.MiExceptionUtil;
import com.mitel.miutil.MiLogMsg.Category;
import java.io.IOException;
import java.nio.channels.DatagramChannel;


/**
 * Active FX UDP connection
 */
public class AfxConnectionUdp extends AfxConnection implements ReactorEventHandler, FsmContext
{
	public AfxConnectionUdp(AfxDomain domain, int localPort)
	{
		super(domain);
		m_LocalPort = localPort;
	}	

	@Override
	public int getConnectionType()
	{
		return AfxConnection.AFX_CONNECTION_UDP;
	}

	public void connect(SocketAddress remote)
	{
		if(null == m_RemoteAddress) {
			m_RemoteAddress = remote;
		}
		else if(!m_RemoteAddress.equals(remote)) {
			MiSystem.logWarning(Category.DESIGN, "Attempted to change " + m_RemoteAddress 
				+ " to " + remote + " rejected request");
		}
	}

	@Override
	public synchronized boolean isOpen()
	{
		if((null != m_Channel)&&(null != m_Channel.socket())) {
			return this.m_Channel.isOpen();
		}

		return false;
	}

	@Override
	@SuppressWarnings("NestedAssignment")
	public void onWrite()
	{
		try
		{
			m_Domain.deregisterHandler(this, SelectionKey.OP_WRITE);
			if(null != m_RemoteAddress)
			{
				int byteWritten;
				if(0 < (byteWritten = m_Channel.send(m_WriteBuffer, m_RemoteAddress)))
				{
					if(byteWritten < m_WriteBuffer.limit()) {
						MiSystem.logWarning(Category.DESIGN, "Datagram only partially written");
					}
	
					// Wrote the entire buffer, don't need write event any more ...
					// ... And trigger the transition on event WRITE_COMPLETE
					m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.WRITE_COMPLETE, this), true);
					return;
				}
				else {
					MiSystem.logWarning(Category.DESIGN, "Send failed");
				}
			}
			else {
				MiSystem.logWarning(Category.DESIGN, "No remote address");
			}

			// Write failed, don't need write event any more ...
			m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.WRITE_FAILURE, this), true);
		}
		catch(IOException ex) {
			MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(ex));
			// Write failed, don't need write event any more ...
			// ... And trigger the transition on event FAILURE
			m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.WRITE_FAILURE, this), true);
		}
	}

	@Override
	public void onAccept()
	{
		m_Domain.deregisterHandler(this, SelectionKey.OP_ACCEPT);
	}

	@Override
	public void onConnect()
	{
		// This is UDP no need for this: m_Domain.m_Reactor.deregisterHandler(this, SelectionKey.OP_CONNECT);
		m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_COMPLETE, this), true);
	}

	@Override
	public void onDisconnect()
	{
		m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.CLOSE, this), false);
	}

	@Override
	public void onRead()
	{
		try
		{
			if((m_ReadBuffer != null)&&(m_ReadBuffer.hasRemaining()))
			{
				SocketAddress sender = m_Channel.receive(m_ReadBuffer);
				if(sender != null)
				{
					m_ReadFailCount = 0;

					// Datagram is a read once process
					m_Domain.deregisterHandler(this, SelectionKey.OP_READ);

					// Trigger the transition on event READ_COMPLETE
					m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.READ_COMPLETE, this), true);

					return;
				}
				else
				{
					// UDP not yet ready for read, though the fact that we're in
					// here means the read flag is on. Continue to wait for just a bit more.
					if(++m_ReadFailCount < 10)
					{
						return;
					}
					MiSystem.logError(Category.DESIGN,
						"For some reason we got no UDP packet for reading, terminate this connection");
				}

				m_ReadFailCount = 0;
				m_Domain.deregisterHandler(this, SelectionKey.OP_READ);
				m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.READ_FAILURE, this), true);
			}
			else
			{
				m_Domain.deregisterHandler(this, SelectionKey.OP_READ);

				// Not ready to accept more read event, stop the reading process ...
				if(m_ReadBuffer == null) {
					MiSystem.logWarning(Category.DESIGN, "Read buffer is NULL");
				}
				else {
					MiSystem.logError(Category.DESIGN, "Data available for read but no room left in read buffer");
				}

				m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.READ_FAILURE, this), true);
			}
		}
		catch(java.io.IOException e)
		{
			MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(e));

			m_Domain.deregisterHandler(this, SelectionKey.OP_READ);

			// Read failed, stop the reading process ...
			m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.READ_FAILURE, this), true);
		}
	}

	@Override
	public int getReceiveBufferSize()
	{
		try
		{
			return m_Channel.socket().getReceiveBufferSize();
		}
		catch(SocketException ex) {
			MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(ex));
		}
		return -1;
	}

	@Override
	public int getSendBufferSize()
	{
		try
		{
			return m_Channel.socket().getSendBufferSize();
		}
		catch(IOException e)
		{
			MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
		}
		return -1;
	}

	@Override
	public void setReceiveBufferSize(int newSize)
	{
		try
		{
			m_Channel.socket().setReceiveBufferSize(newSize);
		}
		catch(IOException e)
		{
			MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
		}
	}

	@Override
	public void setSendBufferSize(int newSize)
	{
		try
		{
			m_Channel.socket().setSendBufferSize(newSize);
		}
		catch(IOException e)
		{
			MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
		}
	}

	@Override
	public SelectableChannel getHandle()
	{
		return m_Channel;
	}

	@Override
	public String toString()
	{
		if(null != m_Channel)
			return "(AfxConnection " + m_Channel.socket().getLocalSocketAddress() + ")";
		
		return "(AfxConnection NULL)";
	}

	@Override
	void handleHandshake(FsmEvent evt)
	{
		MiSystem.logInfo(Category.DESIGN, "Don't handle this event in this class");
	}

	@Override
	void abortHandshake(FsmEvent evt)
	{
		MiSystem.logInfo(Category.DESIGN, "Don't handle this event in this class");
	}

	@Override
	@SuppressWarnings("NestedAssignment")
	void initiateOpen(FsmEvent evt)
	{
		AfxFsmEvent afxEvent = (AfxFsmEvent)evt;
		try
		{
			m_ConnectionventHandler = afxEvent.getEventHandler();

			// Close any existing channel
			if(m_Channel != null)
			{
				m_Channel.close();
			}

			if(null == (m_Channel = (DatagramChannel)afxEvent.getChannel()))
			{
				m_Channel = DatagramChannel.open();
				m_Channel.socket().bind(new InetSocketAddress(m_LocalPort));
				m_Channel.configureBlocking(false);

				if(null != afxEvent.getIpAddr())
					m_RemoteAddress = new InetSocketAddress(afxEvent.getIpAddr(), afxEvent.getIpPort());
			}

			// This is UDP we can't wait for CONNECT event from Reactor for UDP channel
			onConnect();
		}
		catch(IOException e)
		{
			m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_FAILURE, 
				this, e.getMessage()), true);
		}
	}

	@Override
	void initiateClose(FsmEvent evt)
	{
		if(m_Channel != null)
		{
			try
			{
				m_Channel.close();
			}
			catch(IOException e)
			{
				MiSystem.logWarning(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
			}
			m_Channel = null;

			m_Domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.CLOSE_COMPLETE, this), true);

			if(m_ConnectionventHandler != null)
				m_ConnectionventHandler.closed();
		}
	}

	@Override
	void initiateRead(FsmEvent evt)
	{
		// Tells the reactor to notify me of read events
		m_Domain.registerHandler(this, SelectionKey.OP_READ);
	}

	@Override
	void initiateWrite(FsmEvent evt)
	{
		// Tells reactor to notify of write events
		m_Domain.registerHandler(this, SelectionKey.OP_WRITE);
	}

	@Override
	void openComplete(FsmEvent evt)
	{
		if(m_ConnectionventHandler != null)
			m_ConnectionventHandler.openCompleted();
	}

	@Override
	void openFailed(FsmEvent evt)
	{
		AfxFsmEvent afxEvt = (AfxFsmEvent)evt;
		if(m_ConnectionventHandler != null)
			m_ConnectionventHandler.openFailed(afxEvt != null ? afxEvt.getCause() : "unknown");
	}

	@Override
	void readComplete(FsmEvent evt)
	{
		m_ReadBuffer.flip();
		if(m_ReadEventHandler != null)
			m_ReadEventHandler.readCompleted(m_ReadBuffer);
	}

	@Override
	void readFailed(FsmEvent evt)
	{
		if(m_ReadEventHandler != null)
			m_ReadEventHandler.readFailed();
	}

	@Override
	void writeComplete(FsmEvent evt)
	{
		if(null != m_WriteEventHandler)
			m_WriteEventHandler.writeCompleted();
	}

	@Override
	void writeFailed(FsmEvent evt)
	{
		if(null != m_WriteEventHandler)
			m_WriteEventHandler.writeFailed();
	}

	@Override
	void readWriteFailed(FsmEvent evt)
	{
		if(m_ReadEventHandler != null)
			m_ReadEventHandler.readFailed();

		if(null != m_WriteEventHandler)
			m_WriteEventHandler.writeFailed();
	}
	
	@Override
	void initiateConnect(FsmEvent evt) {
	}

	private DatagramChannel m_Channel = null;
	private final int m_LocalPort;

	/** @link dependency */
    /*# AfxReactor lnkAfxReactor; */
	private SocketAddress m_RemoteAddress;

	/** @link dependency */
    /*# AfxFsmEvent lnkAfxFsmEvent; */
	private int m_ReadFailCount = 0;
}
