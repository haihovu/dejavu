/* Generated by Together */

package com.mitel.miutil;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * The default log handler implementation.
 * Basically queues up the log messages and prints them to the stdout, using a separate thread.
 */
public class MiLogHandlerDefault implements MiLogHandler, Runnable
{
	/**
	 * Creates a new instance of the default log handler.
	 * @param queueSize Size of the log queue.
	 */
	public MiLogHandlerDefault(int queueSize)
	{
		m_LogQueue = new LinkedBlockingQueue<MiLogMsg>(queueSize);
	}

	@Override
	public synchronized void start()
	{
		stop();
		setRunFlag(true);
		m_Thread = new Thread(this, "SysLog");
		m_Thread.start();
	}
	
	@Override
	public synchronized void stop()
	{
		setRunFlag(false);
		if(null != m_Thread)
		{
			m_Thread.interrupt();
			
			// Wait for thread to terminate
			try
			{
				m_Thread.join(10000);
			} 
			catch (InterruptedException ex){}
			
			m_Thread = null;
		}
	}
	
	@Override
	public MiLogMsg logMsg(MiLogMsg.Category category, int severity, Class origClass, String origMethod, String message)
	{
		return logMsg(new MiLogMsg(category, severity, origClass, origMethod, message));
	}

	@Override
	public MiLogMsg logMsg(MiLogMsg msg) {
		try
		{
			if(!m_LogQueue.offer(msg, 1, TimeUnit.SECONDS))
			{
				System.err.println("ERROR - " + getClass() + ".logMsg - Queue full");
			}
		}
		catch(InterruptedException ex)
		{
		}
		return msg;
	}

	@Override
	public void setLogFilterLevel(int logLevel)
	{
		m_LogFilterLevel = logLevel;
	}

	@Override
	public int getLogFilterLevel()
	{
		return m_LogFilterLevel;
	}

	@Override
	public void run()
	{
		try
		{
			while(isRunFlag())
			{
				MiLogMsg log = m_LogQueue.poll(2, TimeUnit.SECONDS);
				if(log == null)
					continue;
				System.out.println(log.tsToString() + " - " + log.toString());
			}
		}
		catch(InterruptedException e){}

		// Flush out the rest of the log msgs
		while(true)
		{
			MiLogMsg log = m_LogQueue.poll();
			if(null == log)
			{
				// Log queue is now empty, exit thread
				break;
			}
			System.out.println(log.tsToString() + " - " + log.toString());
		}
	}

	/**
	 * Determines whether the run flag is true
	 * @return The current state of the run flag
	 */
	private synchronized boolean isRunFlag()
	{
		return m_RunFlag;
	}

	/**
	 * Specifies the run flag value
	 * @param newValue The new run flag value
	 * @return This object
	 */
	private synchronized MiLogHandlerDefault setRunFlag(boolean newValue)
	{
		this.m_RunFlag = newValue;
		return this;
	}
	
	private Thread m_Thread;
	private boolean m_RunFlag;
	private final LinkedBlockingQueue<MiLogMsg> m_LogQueue;
	private static volatile int m_LogFilterLevel = 1; // Default log level is Error & Warning
}
