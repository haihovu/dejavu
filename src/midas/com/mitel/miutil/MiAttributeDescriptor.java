/* Generated by Together */

package com.mitel.miutil;

import java.util.HashMap;
import java.util.AbstractMap;
import java.util.HashSet;
import java.util.Set;

/**
 * <p>This class represents generic attribute descriptors.</p>
 * <p>This is not meant to be instantiated directly by client codes. Applications should subclass and define constants representing specific attributes.</p>
 * <p><U>Example:</U></P>
 * <CODE> class MyGreatAttribute extends MiAttributeDescriptor
 * {
 *   public static final MyGreatAttribute ATTRIBUTE_ONE = new MiConfigAttributeName(...);
 *   public static final MyGreatAttribute ATTRIBUTE_TWO = new MiConfigAttributeName(...);
 *   ...
 * }</CODE>
 */
public class MiAttributeDescriptor
{
	/**
	 * Constructor 1.
	 * @param name Name of attribute
	 * @param attClass Class of attribute
	 * @param converter String converter for this attribute type.
	 */
	@SuppressWarnings("LeakingThisInConstructor")
	public MiAttributeDescriptor(String name, Class attClass, StringConverter converter)
	{
		m_Modifiable = true;
		m_Name = name;
		m_Id = name2Id(name);
		m_AttributeClass = attClass;
		m_StringConverter = converter;
		
		registerAttribute(this);
	}

	/**
	 * Constructor 2.
	 * 
	 * @param name Name of attribute
	 * @param attClass Class of attribute
	 * @param modifiable Flag indicating whether the attribute can be modified
	 * @param converter String converter for this attribute type.
	 */
	@SuppressWarnings("LeakingThisInConstructor")
	public MiAttributeDescriptor(String name, boolean modifiable, Class attClass, StringConverter converter)
	{
		m_Name = name;
		m_Id = name2Id(name);
		m_AttributeClass = attClass;
		m_Modifiable = modifiable;
		m_StringConverter = converter;
		
		registerAttribute(this);
	}

	@Override
	public boolean equals(Object rhs)
	{
		if(this != rhs)
		{
			if(rhs instanceof MiAttributeDescriptor)
			{
				MiAttributeDescriptor rhsAtt = (MiAttributeDescriptor)rhs;
	
				return (hashCode() == rhsAtt.hashCode());
			}
			return false;
		}
		return true;
	}

	@Override
	public int hashCode()
	{
		// This stuff was generated by Netbeans, yay.
		int hash = 3;
		hash = 37 * hash + this.m_Id;
		return hash;
	}

	@Override
	public String toString()
	{
		return this.m_Name;
	}

	/**
	 * Locates a MiConfigAttributeName given its integer ID.
	 * @param id The integer ID of the desired attribute
	 * @return The requested attribute, or null if no match is found.
	 */
	public static MiAttributeDescriptor locateAttribute(int id)
	{
		if(id < s_AttMap.length)
		{
			MiAttributeDescriptor value = s_AttMap[id];
			if(null != value)
			{
				return value;
			}
			else
			{
				MiSystem.logError(MiLogMsg.Category.DESIGN,
					"Id " + id + " not registered.");
			}
		}
		else
		{
			MiSystem.logError(MiLogMsg.Category.DESIGN,
				"Id " + id + " out of range.");
		}
		return null;
	}

	/**
	 * Locates a MiAttributeDescriptor given its string name.
	 * @param name Name of the desired attribute
	 * @return The requested attribute, or null if no match is found.
	 */
	public static MiAttributeDescriptor locateAttribute(String name)
	{
		Integer id = null;
		synchronized(s_Name2IdMap)
		{
			id = s_Name2IdMap.get(name);
		}
		if(id != null)
		{
			int idx = id.intValue();
			synchronized(s_AttMap)
			{
				if(idx < s_AttMap.length)
				{
					return s_AttMap[idx];
				}
			}
		}

		MiSystem.logError(MiLogMsg.Category.DESIGN,
			"Failed to locate attritbute " + name);
		
		return null;
	}

	/**
	 * Registers a new unique attribute.
	 * The new attribute is added to the attribute map, keyed by its Integer ID.
	 * @param att The attribute to be registered
	 */
	protected static void registerAttribute(MiAttributeDescriptor att)
	{
		synchronized(s_AttMap)
		{
			s_AttMap[att.m_Id] = att;
		}
	}

	/**
	 * Given a unique attribute name, returns a unique attribute ID.
	 * @param attName
	 * @return
	 */
	private static int name2Id(String attName)
	{
		synchronized(s_Name2IdMap)
		{
			// Check to see if the name is already in the s_Name2IdMap map.
			Integer retValue = s_Name2IdMap.get(attName);
			if(null == retValue)
			{
				// If not then creates a new unique ID and then add it to the map
				retValue = new Integer(IdCounter++);
				s_Name2IdMap.put(attName, retValue);
			}
			return retValue.intValue();
		}
	}

	/**
	 * Integer ID of attribute, used as index into the attribute array of MiConfig.
	 * This is system-wide unique ID as opposed to m_Type which is only supposed to be unique among a particular class.
	 */
	public final int m_Id;

	/**
	 * Name (String ID) of attribute.
	 */
	public final String m_Name;

	/**
	 * Determines whether the attribute is editable against a message.
	 * Some attribute such as MiNet type and MTS22 type are preset against the specific types of MiNet messages and may not be changed. 
	 * True by default.
	 */	
	public final boolean m_Modifiable;

	/**
	 * The class of the attribute values. E.g. Integer, String, SomeClass, ...
	 */
	public final Class m_AttributeClass;
	
	/**
	 * Used with complex attributes to convert their values to/from String format.
	 */
	protected final StringConverter m_StringConverter;
	
	/**
	 * Used for generating system-wide unique ID's for the attribute names.
	 */
	private static int IdCounter = 1;

	/**
	 * Look up table used for associating a unique string name of an attribute with the equivalent unique integer ID.
	 * Keys are the string names, values are the associated Integer values.
	 */
	private static final AbstractMap<String, Integer> s_Name2IdMap = new HashMap<String, Integer>();

	/**
	 * Static Mapping between attributes' integer ID's and the associated MiNetAttribute objects.
	 */	
	private static final MiAttributeDescriptor[] s_AttMap = new MiAttributeDescriptor[1024];

	/**
	 * Custom exception used with MiAttribute
	 */
	public static final class MiAttributeException extends Exception
	{
		private static final long serialVersionUID = 1L;
		public MiAttributeException()
		{
			super();
		}
		public MiAttributeException(String msg)
		{
			super(msg);
		}
		public MiAttributeException(String msg, Throwable cause)
		{
			super(msg, cause);
		}
		public MiAttributeException(Throwable cause)
		{
			super(cause);
		}
	}
	
	/**
	 * Interface for converting complex attribute values to/from String format.
	 */
	public interface StringConverter
	{
		/**
		 * Converts an object to its String representation.
		 * @param attributeValue The object to be converted.
		 * @return The String representation of the object.
		 * @throws com.mitel.miutil.MiAttributeDescriptor.MiAttributeException 
		 */
		public String toString(Object attributeValue) throws MiAttributeException;
		/**
		 * Converts a String to its equivalent object.
		 * @param attributeValue The String to be converted.
		 * @return The object equivalent of the given String, or null if the String given was invalid for this type.
		 * @throws com.mitel.miutil.MiAttributeDescriptor.MiAttributeException
		 */
		public Object fromString(String attributeValue) throws MiAttributeException;
		/**
		 * Retrieves the discrete set of values represented this data type, where appropriate. 
		 * If the data type is continuous then an empty set is returned, i.e. the return value is never null.
		 * @return The Set representing all possible discrete values of this data type.
		 */
		public Set getValueSet();
	}

	/**
	 * Converts an object to the equivalent String value.
	 * The StringConverter will be consulted if specified, otherwise the method toString() of the object will be used.
	 * @param value The object to be converted.
	 * @return The string representation of the given object, guarantee to return non-null value.
	 */
	public String objToString(Object value)
	{
		if(null != value)
		{
			if(m_StringConverter != null)
			{
				try
				{
					return m_StringConverter.toString(value);
				}
				catch(MiAttributeException ex)
				{
					MiSystem.logError(MiLogMsg.Category.DESIGN, MiExceptionUtil.simpleTrace(ex));
				}
			}

			return value.toString();
		}
		return "";
	}

	/**
	 * Retrieves the discrete set of values represented this data type, where appropriate. 
	 * If the data type is continuous then an empty set is returned, i.e. the return value is never null.
	 * @return The Set representing all possible discrete values of this data type.
	 */
	public Set getValueSet()
	{
		if(m_StringConverter != null)
		{
			return m_StringConverter.getValueSet();
		}
		
		return new HashSet();
	}

	/**
	 * Converts a String value to the equivalent object of this particular data type.
	 * @param value The string value to be converted to the object.
	 * @return The Object that represents the given value. The type of object is dependent on the data type represented by this attribute.
	 */
	public Object stringToObj(String value)
	{
		try
		{
			if(m_StringConverter != null)
			{
				return m_StringConverter.fromString(value);
			}
			else if(m_AttributeClass == Integer.class)
			{
				return Integer.valueOf(value);
			}
			else if(m_AttributeClass == String.class)
			{
				return value;
			}
			else if(m_AttributeClass == Double.class)
			{
				return Double.valueOf(value);
			}
			else if(m_AttributeClass == Boolean.class)
			{
				return Boolean.valueOf(value);
			}
		}
		catch(MiAttributeException ex)
		{
			MiSystem.logWarning(MiLogMsg.Category.DESIGN, MiExceptionUtil.simpleTrace(ex));
		}
		catch(RuntimeException ex)
		{
			MiSystem.logError(MiLogMsg.Category.DESIGN, MiExceptionUtil.simpleTrace(ex));
		}
		
		return null;
	}
}
