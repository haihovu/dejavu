/* Generated by Together */

package com.mitel.miutil;

import java.io.*;
import java.util.Map;
import java.util.Set;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

/**
 * System utility containing system-related functions.
 * This is an abstract class that applications can extend in order to customize 
 * behaviour such as how system properties are managed.
 * A default implementation is provided by MiDAS, {@link MiSystemDefault},
 * it is recommended that application extend MiSystemDefault instead of MiSystem directly.
 */
public abstract class MiSystem
{
	/**
	 * @supplierCardinality 1
	 * @label singletonImpl 
	 */
	private static MiSystem s_Singleton;

	/** @link dependency */
    /*# MiSystemDefault lnkMiSystemDefault; */	

	/**
	 * Determines whether the log level is set to include trace, i.e. log level > 2.
	 * @return True if trace is on, false otherwise.
	 */
	public static boolean traceOn()
	{
		return (getLogLevel() > 2);
	}

	/**
	 * Given a fully qualified directory name, create it along with any parent directories required.
	 * @param dir The fully qualified name of the directory to be created.
	 * @param deleteOnExit Flag indicating whether the created directory will be automatically deleted on exit.
	 */
	private static void createDir(File dir, boolean deleteOnExit)
	{
		File parent = dir.getParentFile();
		if(parent != null)
		{
			createDir(parent, deleteOnExit);
		}
		if(!dir.exists())
		{
			dir.mkdir();
			if(deleteOnExit)
			{
				dir.deleteOnExit();
			}
		}
	}

	/**
	 * Writes a specific artifact from the class loader (JAR) to a directory on the host as a file.
	 * @param classLoader The class loader with which to retrieve the artifact.
	 * @param artifactName The fully qualified artifact name
	 * @param deleteOnExit Whether the artifact is to be deleted on exit of the application
	 * @param outDir The output directory into which to save the desired artifact.
	 * @param type Whether the artifact being written is binary or text (ASCII).
	 * @return The resulting artifact file.
	 * @throws IOException
	 */
	private static File createArtifactFile(ClassLoader classLoader, String artifactName, File outDir, boolean deleteOnExit, ArtifactDesc.Type type) throws IOException
	{
		File outFile = new File(outDir.toString() + File.separator + artifactName);
		createDir(outFile.getParentFile(), deleteOnExit);

		InputStream inStream = classLoader.getResourceAsStream(artifactName);
		if(inStream == null)
		{
			throw new IOException(artifactName + " does not exist");
		}
		
		try
		{
			OutputStream outStream = new FileOutputStream(outFile);
			try
			{
				outFile.deleteOnExit();
				if(type == ArtifactDesc.Type.BINARY)
				{
					byte[] buf = new byte[1024];
					int bytes = inStream.read(buf);
					while(bytes > 0)
					{
						outStream.write(buf, 0, bytes);
						bytes = inStream.read(buf);
					}
				}
				else
				{
					Writer w = new OutputStreamWriter(outStream);
					try
					{
						char[] cbuf = new char[1024];
						Reader r = new InputStreamReader(inStream);
						try
						{
							int bytes = r.read(cbuf);
							while(bytes > 0)
							{
								w.write(cbuf, 0, bytes);
								bytes = r.read(cbuf);
							}
						}
						finally
						{
							r.close();
						}
					}
					finally
					{
						w.close();
					}
				}
			}
			finally
			{
				outStream.close();
			}
		}
		finally
		{
			inStream.close();
		}
		return outFile;
	}

	/**
	 * A structure that describes a single artifact such as help content, basically any file included
	 * in the JARs such as HTML, image, CSS, etc.
	 */
	public static class ArtifactDesc
	{
		public static enum Type
		{
			BINARY,
			TEXT
		}
		
		/**
		 * The class loader with which to retrieve the artifact.
		 */
		public final ClassLoader classLoader;
		/**
		 * The fully qualified artifact name
		 */
		public final String artifactName;
		/**
		 * Is the artifact binary or text
		 */
		public final Type artifactType;
		/**
		 * Is this the entry point artifact, the initial HTML file so to speak.
		 */
		public final boolean isEntryPoint;
		/**
		 * Creates a new help artifact descriptor
		 * @param cLoader The class loader with which to retrieve the artifact.
		 * @param aName The fully qualified artifact name
		 * @param type Is the artifact binary or text
		 * @param entryPoint Is this the entry point artifact, the initial HTML file so to speak.
		 */
		public ArtifactDesc(ClassLoader cLoader, String aName, Type type, boolean entryPoint)
		{
			classLoader = cLoader;
			artifactName = aName;
			artifactType = type;
			isEntryPoint = entryPoint;
		}
	}

	/**
	 * Retrieves the list of artifacts required to support MiDAS CSS.
	 * @return The list of MiDAS CSS, non-null.
	 */
	@SuppressWarnings("ReturnOfCollectionOrArrayField")
	public static ArtifactDesc[] getMidasCssArtifacts()
	{
		return gMidasCssArtifacts;
	}

	/**
	 * Creates the artifacts of a set of help content (typically web pages and associated things
	 * like images and CSS files) on the local drive to allow web browsers to access them.
	 * This means retrieving the artifacts from the JAR file(s) and saving them on to a particular
	 * directory on the local drive.
	 * @param localDir The local directory in which to save the help content artifacts
	 * @param artifacts The description of the artifacts to be created
	 * @param deleteOnExit Whether the artifacts will be automatically deleted when the application exits.
	 * @return The entry file into the help content, typically an HTML file.
	 * @throws IOException
	 */
	public static File createHelpContentArtifact(File localDir, ArtifactDesc[] artifacts, boolean deleteOnExit) throws IOException
	{
		File ret = null;

		for(ArtifactDesc artifact : artifacts)
		{
			File f = createArtifactFile(artifact.classLoader, artifact.artifactName, localDir, deleteOnExit, artifact.artifactType);
			if(artifact.isEntryPoint)
			{
				ret = f;
			}
		}

		return ret;
	}
	
	/**
	 * Sets the system log level, the higher the level, the more verbose the log output will be.
	 * @param logLevel The log level as described below:
	 * <ul>
	 * <li>0 - Only error messages will be generated.</li>
	 * <li>1 - Error & Warning messages will be generated.</li>
	 * <li>2 - Error & Warning & Info messages will be generated.</li>
	 * <li>3 - Error & Warning & Info & Trace messages will be generated.</li>
	 * </ul>
	 */
	public static void setLogLevel(int logLevel)
	{
		s_LogLevel = logLevel;
		
		MiLogHandler logHandler = getLogHandler();
		setProperty(MiSystemProperty.MIPROPERTY_LOG_LEVEL, String.valueOf(logLevel));
		if(null != logHandler)
		{
			logHandler.setLogFilterLevel(logLevel);
		}
	}

	/**
	 * Retrieves the current system log level, the higher the level, the more verbose the log output will be.
	 * The log levels are described below:
	 * <ul>
	 * <li>0 - Only error messages will be generated.</li>
	 * <li>1 - Error & Warning messages will be generated.</li>
	 * <li>2 - Error & Warning & Info messages will be generated.</li>
	 * <li>3 - Error & Warning & Info & Trace messages will be generated.</li>
	 * </ul>
	 * @return The log level currently set.
	 */
	public static int getLogLevel()
	{
		MiLogHandler handler = getLogHandler();
		if(null != handler)
		{
			return handler.getLogFilterLevel();
		}
		return s_LogLevel;
	}

	/**
	 * Sets the version of a component.
	 * @param component Name of component whose version is to be set
	 * @param version The new version value
	 */
	public static void setVersion(String component, String version)
	{
		getImpl().sysSetVersion(component, version);
	}

	/**
	 * Gets the version of a component.
	 * @param component The target component whose version is being requested.
	 * @return The version of the desired component or empty string if the specified component could not be found.
	 */
	public static String getVersion(String component)
	{
		return getImpl().sysGetVersion(component);
	}

	private static StackTraceElement retrieveCallerTrace(int skip, StackTraceElement[] traces)
	{
		if(traces.length > skip)
		{
			return traces[skip];
		}
		else if(traces.length > 0)
		{
			return traces[traces.length - 1];
		}
		return Thread.currentThread().getStackTrace()[0];
	}
	
	/**
	 * Generate a trace log message. Typically used by designer to generate debug messages.
	 * @param cat The category of the log message being generated
	 * @param srcClass Class of the object from which the log is generated, just a way for designer to figure out where the log came from
	 * @param functionName Name of the function from whence the log came, again just a way for designer to figure out where the log came from
	 * @param message The log message
	 * @return The log message that was generated or null if none was generated, e.g. if the filter
	 * causes the message to be discarded.
	 */
	public static MiLogMsg logTrace(MiLogMsg.Category cat, Class srcClass, String functionName, String message)
	{
		if(getLogLevel() < 3)
		{
			// Trace is filtered
			return null;
		}

		MiLogHandler logHandler = getLogHandler();
		if(null != logHandler)
		{
			return logHandler.logMsg(cat, 3, srcClass, functionName, message);
		}
		return null;
	}

	/**
	 * Generate an info log message. Typically used by designer to record progress events.
	 * @param cat The category of the log message being generated
	 * @param srcClass Class of the object from which the log is generated, just a way for designer to figure out where the log came from
	 * @param functionName Name of the function from whence the log came, again just a way for designer to figure out where the log came from
	 * @param message The log message
	 * @return The log message that was generated or null if none was generated, e.g. if the filter
	 * causes the message to be discarded.
	 */
	public static MiLogMsg logInfo(MiLogMsg.Category cat, Class srcClass, String functionName, String message)
	{
		if(getLogLevel() < 2)
		{
			// Info is filtered
			return null;
		}

		MiLogHandler logHandler = getLogHandler();
		if(null != logHandler)
		{
			return logHandler.logMsg(cat, 2, srcClass, functionName, message);
		}
		return null;
	}

	/**
	 * Generate an info log message. Typically used by designer to record progress events.
	 * @param cat The category of the log message being generated
	 * @param message The log message
	 * @return The log message that was generated or null if none was generated, e.g. if the filter
	 * causes the message to be discarded.
	 */
	public static MiLogMsg logInfo(MiLogMsg.Category cat, String message)
	{
		Class srcClass = MiSystem.class;
		StackTraceElement callerTrace = retrieveCallerTrace(2, Thread.currentThread().getStackTrace());
		try
		{
			srcClass = Class.forName(callerTrace.getClassName());
		}
		catch(ClassNotFoundException ex)
		{
		}
		return logInfo(cat, srcClass, callerTrace.getMethodName(), message);
	}

	/**
	 * Generate a warning log message. Significant events typically denote unusual runtime conditions.
	 * @param cat The category of the log message being generated
	 * @param srcClass Class of the object from which the log is generated, just a way for designer to figure out where the log came from
	 * @param functionName Name of the function from whence the log came, again just a way for designer to figure out where the log came from
	 * @param message The log message
	 * @return The log message that was generated or null if none was generated, e.g. if the filter
	 * causes the message to be discarded.
	 */
	public static MiLogMsg logWarning(MiLogMsg.Category cat, Class srcClass, String functionName, String message)
	{
		if(getLogLevel() < 1)
		{
			// Warning is filtered
			return null;
		}

		MiLogHandler logHandler = getLogHandler();
		if(null != logHandler)
		{
			return logHandler.logMsg(cat, 1, srcClass, functionName, message);
		}
		return null;
	}

	/**
	 * Generate a warning log message. Significant events typically denote logic failure, things that should never happen but did.
	 * @param cat The category of the log message being generated
	 * @param message The log message
	 * @return The log message that was generated or null if none was generated, e.g. if the filter
	 * causes the message to be discarded.
	 */
	public static MiLogMsg logWarning(MiLogMsg.Category cat, String message)
	{
		Class srcClass = MiSystem.class;
		StackTraceElement callerTrace = retrieveCallerTrace(2, Thread.currentThread().getStackTrace());
		try
		{
			srcClass = Class.forName(callerTrace.getClassName());
		}
		catch(ClassNotFoundException ex)
		{
		}
		return logWarning(cat, srcClass, callerTrace.getMethodName(), message);
	}

	/**
	 * Generate an error log message. Significant events typically denote logic failure, things that should never happen but did.
	 * @param cat The category of the log message being generated
	 * @param srcClass Class of the object from which the log is generated, just a way for designer to figure out where the log came from
	 * @param functionName Name of the function from whence the log came, again just a way for designer to figure out where the log came from
	 * @param message The log message
	 * @return The log message that was generated or null if none was generated, e.g. if the filter
	 * causes the message to be discarded.
	 */
	public static MiLogMsg logError(MiLogMsg.Category cat, Class srcClass, String functionName, String message)
	{
		MiLogHandler logHandler = getLogHandler();
		if(null != logHandler)
		{
			return logHandler.logMsg(cat, 0, srcClass, functionName, message);
		}
		return null;
	}

	/**
	 * Generate an error log message. Significant events typically denote logic failure, things that should never happen but did.
	 * @param cat The category of the log message being generated
	 * @param message The log message
	 * @return The log message that was generated or null if none was generated, e.g. if the filter
	 * causes the message to be discarded.
	 */
	public static MiLogMsg logError(MiLogMsg.Category cat, String message)
	{
		Class srcClass = MiSystem.class;
		StackTraceElement callerTrace = retrieveCallerTrace(2, Thread.currentThread().getStackTrace());
		try
		{
			srcClass = Class.forName(callerTrace.getClassName());
		}
		catch(ClassNotFoundException ex)
		{
		}
		return logError(cat, srcClass, callerTrace.getMethodName(), message);
	}

	/**
	 * Retrieves a system property identified by its unique name.
	 * @param propertyName Name of the desired property
	 * @return The value of the requested property, 
	 * empty string if there is no property matching the specified name.
	 */
	public static String getProperty(String propertyName)
	{
		return getImpl().sysGetProperty(propertyName);
	}
	
	/**
	 * Sets a system property.
	 * @param propertyName Name of the desired property
	 * @param value The new value with which to set the specified property.
	 */
	public static void setProperty(String propertyName, String value)
	{
		getImpl().sysSetProperty(propertyName, value);
	}

	/**
	 * Imports system properties from an XML document that was previously exported via exportProperties().
	 * Typically used at startup to restore the system properties from some saved files.
	 * @param xmlDoc The XML document containing the properties to be imported.
	 */
	public static void importProperties(Document xmlDoc)
	{
		getImpl().sysImportProperties(xmlDoc);
	}
	
	/**
	 * Exports all system properties to an XML element.
	 * Typically used at shutdown to save the system properties to some files.
	 * @param xmlDoc The root XML document used to generate XML elements representing the system properties.
	 * @return The top-level XML element containing all system properties.
	 */
	public static Element exportProperties(Document xmlDoc)
	{
		return getImpl().sysExportProperties(xmlDoc);
	}
	
	/**
	 * Retrieves ALL system properties.
	 * @return The set of name-value pairs representing all system properties.
	 */
	public static Set<Map.Entry<String,String>> getProperties()
	{
		return getImpl().sysGetProperties();
	}
	
	/**
	 * Registers a concrete implementation of the MiLogHandler class.
	 * Only one instance of MiLogHandler may be registered. Log requests
	 * are forwarded to the registered handler.
	 * @param handler The concrete MiLogHandlder implementation.
	 */
	public static void registerLogHandler(MiLogHandler handler)
	{
		synchronized(s_LogLock)
		{
			if(null != s_LogHandler)
			{
				s_LogHandler.stop();
			}
			s_LogHandler = handler;
		}
	}

	/**
	 * Deregisters the implementation of the MiLogHandler class.
	 */
	public static void deregisterLogHandler()
	{
		synchronized(s_LogLock)
		{
			if(null != s_LogHandler)
			{
				s_LogHandler.stop();
			}
			s_LogHandler = null;
		}
	}

	/**
	 * Retrieves the registered MiLogHandler implementation.
	 * @return The registered log handler, or a default one if none was registered.
	 */
	public static MiLogHandler getLogHandler()
	{
		synchronized(s_LogLock)
		{
			if(null == s_LogHandler)
			{
				// If no log handler already registered then use a simple implementation
				s_LogHandler = new MiLogHandler()
				{
					private int m_LogLevel = 1;
					@Override
					public synchronized int getLogFilterLevel()
					{
						return m_LogLevel;
					}
					
					@Override
					public MiLogMsg logMsg(MiLogMsg.Category category, int severity, Class origClass, String origMethod, String message)
					{
						return logMsg(new MiLogMsg(category, severity, origClass, origMethod, message));
					}

					@Override
					public MiLogMsg logMsg(MiLogMsg msg) {
						System.out.println(msg.tsToString() + " - " + msg.toString());
						return msg;
					}
					
					@Override
					public synchronized void setLogFilterLevel(int logLevel)
					{
						m_LogLevel = logLevel;
					}
					
					@Override
					public void start()
					{
					}
					
					@Override
					public void stop()
					{
					}
				};
			}
			return s_LogHandler;
		}
	}

	/**
	 * Registers a concrete implementation of the MiSystem class.
	 * Typically done at start up by the application.
	 * @param impl The concrete implementation.
	 */
	public static void registerImpl(MiSystem impl)
	{
		if(impl != null)
		{
			synchronized(staticLock)
			{
				s_Singleton = impl;
			}
		}
	}

	/**
	 * Deregisters the implementation.
	 * @param impl The concrete implementation to deregister.
	 */
	public static void deregisterImpl(MiSystem impl)
	{
		synchronized(staticLock)
		{
			if(s_Singleton == impl)
				s_Singleton = null;
		}
	}

	/**
	 * Retrieves the registered MiSystem implementation.
	 * @return The regsitered implementation.
	 */
	private static MiSystem getImpl()
	{
		synchronized(staticLock)
		{
			if(null == s_Singleton)
			{
				s_Singleton = new MiSystemDefault();
			}
			return s_Singleton;
		}
	}

	/**
	 * Default constructor.
	 */
	protected MiSystem()
	{
	}

	/**
	 * Sets the version of a component.
	 * To be implemented by concrete sub-classes.
	 * @param component The name of the target component.
	 * @param version The version to set
	 */
	protected abstract void sysSetVersion(String component, String version);

	/**
	 * Gets the version of a component.
	 * To be implemented by concrete sub-classes.
	 * @param component The name of the component whose version is being requested.
	 * @return The version of the requested component, or empty string if component does not exist.
	 */
	protected abstract String sysGetVersion(String component);

	/**
	 * Retrieves the value of a system property.
	 * To be implemented by concrete sub-classes.
	 * @param propertyName Name of the desired property.
	 * @return The value of the requested property, empty string if there is no property matching the specified name.
	 */
	protected abstract String sysGetProperty(String propertyName);

	/**
	 * Sets a system property.
	 * To be implemented by concrete sub-classes.
	 * @param propertyName Name of the desired property
	 * @param value The new value with which to set the specified property.
	 */
	protected abstract void sysSetProperty(String propertyName, String value);

	/**
	 * Exports all system properties to an XML element.
	 * To be implemented by concrete sub-classes.
	 * Typically used at shutdown to save the system properties to some files.
	 * To be implemented by concrete sub-classes.
	 * @param ownerDoc The root XML document used to generate XML elements representing the system properties.
	 * @return The top-level XML element containing all system properties.
	 */
	protected abstract Element sysExportProperties(Document ownerDoc);

	/**
	 * Imports system properties from an XML document that was previously exported via exportProperties().
	 * Typically used at startup to restore the system properties from some saved files.
	 * To be implemented by concrete sub-classes.
	 * @param xmlDocument The XML document containing the properties to be imported.
	 */
	protected abstract void sysImportProperties(Document xmlDocument);

	/**
	 * Retrieves ALL system properties.
	 * @return The set of name-value pairs representing all system properties.
	 */
	protected abstract Set<Map.Entry<String,String>> sysGetProperties();

	/**
	 * Flag for use with the various log methods. Software log messages are meant to be seen by Mobile Extension software designers.
	 */
	public static final int SYSTEM_SOFTWARE_LOG = 1;
	
	/**
	 * Flag for use with the various log methods. Maintenance log messages are meant to be seen by Mobile Extension users, particularly the system administrator.
	 */
	public static final int SYSTEM_MAINTENANCE_LOG = 2;
	
	private static final Object staticLock = new Object();

	/**
	 * The registered log handler
	 */
	private static volatile MiLogHandler s_LogHandler;
	/**
	 * The log filter level
	 */
	private static volatile int s_LogLevel;
	/**
	 * Used for synchronization when dealing with logging.
	 */
	private static final Object s_LogLock = new Object();

	private static final ArtifactDesc[] gMidasCssArtifacts;

	private static boolean s_DiagnosticEnabled;

	public static void enableDiagnostic()
	{
		s_DiagnosticEnabled = true;
		setProperty(MiSystemProperty.MIPROPERTY_DIAGNOSTIC_ENABLED, Boolean.toString(true));
	}

	public static void disableDiagnostic()
	{
		s_DiagnosticEnabled = false;
		setProperty(MiSystemProperty.MIPROPERTY_DIAGNOSTIC_ENABLED, Boolean.toString(false));
	}
	
	public static boolean diagnosticEnabled()
	{
		return s_DiagnosticEnabled;
	}

	static
	{
		ClassLoader classLoader = MiSystem.class.getClassLoader();
		gMidasCssArtifacts = new ArtifactDesc[]
		{
			new MiSystem.ArtifactDesc(classLoader, "midasstyle.css", MiSystem.ArtifactDesc.Type.TEXT, false),
			new MiSystem.ArtifactDesc(classLoader, "midasstyle_iehacks.css", MiSystem.ArtifactDesc.Type.TEXT, false),
			new MiSystem.ArtifactDesc(classLoader, "images/bg_mitel.gif", MiSystem.ArtifactDesc.Type.BINARY, false),
			new MiSystem.ArtifactDesc(classLoader, "images/bg_mitel_lite.gif", MiSystem.ArtifactDesc.Type.BINARY, false),
			new MiSystem.ArtifactDesc(classLoader, "images/bg_mitel_dark.gif", MiSystem.ArtifactDesc.Type.BINARY, false),
			new MiSystem.ArtifactDesc(classLoader, "images/bg_mitel_code.gif", MiSystem.ArtifactDesc.Type.BINARY, false),
			new MiSystem.ArtifactDesc(classLoader, "images/bg_app_select.png", MiSystem.ArtifactDesc.Type.BINARY, false),
			new MiSystem.ArtifactDesc(classLoader, "images/bg_menu.jpg", MiSystem.ArtifactDesc.Type.BINARY, false),
			new MiSystem.ArtifactDesc(classLoader, "images/gradient_grey.png", MiSystem.ArtifactDesc.Type.BINARY, false),
		};
	}
}
