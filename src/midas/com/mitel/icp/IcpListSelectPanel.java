/*
 * IcpListSelectPanel.java
 *
 * Created on May 22, 2004, 2:07 PM
 */

package com.mitel.icp;

import com.mitel.icp.IcpListManager.ListManagerListener;
import com.mitel.miutil.MiExceptionUtil;
import com.mitel.miutil.MiLogMsg.Category;
import com.mitel.miutil.MiSystem;
import com.mitel.netutil.FtpClient;
import com.mitel.netutil.MiTelnet;
import java.awt.Frame;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.*;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;

/**
 * The GUI panel that is used to manage a list of preconfigured ICP's (via their
 * descriptors).
 * @author Hai Vu
 */
public class IcpListSelectPanel extends javax.swing.JPanel
{
	private static final long serialVersionUID = 1L;
	
	/**
	 * Creates new form IcpListSelectPanel
	 * @param parent
	 */
	public IcpListSelectPanel(Frame parent)
	{
		initComponents();
		m_ParentFrame = parent;
		updateHostNameField();
	}
	
	public synchronized IcpDescriptor getSelectedIcp()
	{
		return IcpRepository.getInstance().getIcp(m_selectedIcpName);
	}
	
	public void setSelectedIcp(String hostName)
	{
		class SelectedIcpUpdater implements Runnable
		{
			private String m_name;
			
			SelectedIcpUpdater(String selectedIcpName)
			{
				m_name = selectedIcpName;
			}
			
			public void run()
			{
				try
				{
					if(null != m_name)
					{
						synchronized(IcpListSelectPanel.this)
						{
							if(icpNameSelect.getItemCount() > 0)
							{
								int selectedIndex = 0;
								for(int i = icpNameSelect.getItemCount() - 1; i >=0; --i)
								{
									String name = (String)icpNameSelect.getItemAt(i);
									if(m_name.equals(name))
									{
										selectedIndex = i;
										break;
									}
								}
								icpNameSelect.setSelectedIndex(selectedIndex);
							}
						}
					}
				}
				catch(Exception e)
				{
					MiSystem.logError(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
				}
			}
		}
		synchronized(this) {
			m_selectedIcpName = hostName;
		}
		SwingUtilities.invokeLater(new SelectedIcpUpdater(hostName));
	}
	
	/**
	 * Opens and returns an FTP session to the selected ICP.
	 * @param timeoutMs
	 * @return The FTP client, or null if one cannot be opened.
	 */
	public FtpClient openFtp(int timeoutMs)
	{
		IcpFtpClient ftp = null;
		try
		{
			ftp = new IcpFtpClient(m_ParentFrame, getSelectedIcp(), IcpProcessor.ProcessorName.RTC, timeoutMs);
			Thread workerThread = new Thread(ftp);
			workerThread.start();
			workerThread.join(timeoutMs);
			ftp.close();
			return ftp.getSession();
		}
		catch(RuntimeException e)
		{
			if(null != ftp)
				ftp.close();
			
			MiSystem.logError(Category.DESIGN, MiExceptionUtil.simpleTrace(e));
		}
		catch(InterruptedException ex)
		{
			ftp.close();
		}
		return null;
	}

	/**
	 * Opens and returns a secured telnet session to the selected ICP.
	 * @param processorName
	 * @param timeoutMs
	 * @return The requested telnet session, not null.
	 * @throws InterruptedException
	 */
	public MiTelnet openTelnet(IcpProcessor.ProcessorName processorName, int timeoutMs) throws InterruptedException
	{
		IcpTelnetClient telnet = new IcpTelnetClient(m_ParentFrame, getSelectedIcp(), processorName);
		Thread workerThread = new Thread(telnet);
		workerThread.start();
		workerThread.join(timeoutMs);
		if(null == telnet.getSession())
		{
			throw new InterruptedException("Timed Out");
		}
		return telnet.getSession();
	}

	/**
	 * Determine if an ICP (by its name) is in the ICP list being managed.
	 * @param icpHostName The name of the desired ICP
	 * @return True if the given ICP is in the list.
	 */
	public boolean isIcpInList(String icpHostName)
	{
		return IcpRepository.getInstance().isIcpInList(icpHostName);
	}

	public void removeActionListener(ActionListener listener)
	{
		synchronized(m_actionListeners) {
			m_actionListeners.remove(listener);
		}
	}

	public void addActionListener(ActionListener listener)
	{
		synchronized(m_actionListeners) {
			m_actionListeners.add(listener);
		}
	}

	/**
	 * @param args the command line arguments
	 */
	public static void main(String[] args)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				IcpService.getInstance();

				JFrame testFrame = new JFrame();
				IcpListSelectPanel myPanel = new IcpListSelectPanel(testFrame);

				testFrame.getContentPane().add(myPanel);
				testFrame.setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
				testFrame.pack();
				testFrame.setVisible(true);
			}
		});
	}
	
	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        icpNameSelect = new javax.swing.JComboBox();
        icpAddRemoveEditButton = new javax.swing.JButton();

        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("com/mitel/icp/IcpManagement"); // NOI18N
        setBorder(javax.swing.BorderFactory.createTitledBorder(bundle.getString("icpList"))); // NOI18N
        setLayout(new java.awt.GridBagLayout());

        icpNameSelect.setMaximumRowCount(10);
        icpNameSelect.addPopupMenuListener(m_filterActionListener);
        icpNameSelect.addActionListener(m_filterActionListener);
        icpNameSelect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                icpNameSelectActionPerformed(evt);
            }
        });
        icpNameSelect.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                icpNameSelectFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                icpNameSelectFocusLost(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.weightx = 0.8;
        gridBagConstraints.insets = new java.awt.Insets(4, 4, 4, 4);
        add(icpNameSelect, gridBagConstraints);

        icpAddRemoveEditButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/images/table_edit.png"))); // NOI18N
        icpAddRemoveEditButton.setToolTipText(bundle.getString("addRemoveEditLable")); // NOI18N
        icpAddRemoveEditButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                icpAddRemoveEditButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.ipadx = 2;
        gridBagConstraints.ipady = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(8, 8, 8, 8);
        add(icpAddRemoveEditButton, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents

	private void icpNameSelectFocusLost(java.awt.event.FocusEvent evt)//GEN-FIRST:event_icpNameSelectFocusLost
	{//GEN-HEADEREND:event_icpNameSelectFocusLost
		IcpRepository.getInstance().removeObserver(m_IcpRepositpryObserver);
	}//GEN-LAST:event_icpNameSelectFocusLost

	private void icpNameSelectFocusGained(java.awt.event.FocusEvent evt)//GEN-FIRST:event_icpNameSelectFocusGained
	{//GEN-HEADEREND:event_icpNameSelectFocusGained
		updateHostNameField();
		IcpRepository.getInstance().addObserver(m_IcpRepositpryObserver);
	}//GEN-LAST:event_icpNameSelectFocusGained

	private void icpNameSelectActionPerformed(ActionEvent evt)//GEN-FIRST:event_icpNameSelectActionPerformed
	{//GEN-HEADEREND:event_icpNameSelectActionPerformed
		synchronized(this) {
			m_selectedIcpName = (String)icpNameSelect.getSelectedItem();
		}
	}//GEN-LAST:event_icpNameSelectActionPerformed

	private void icpAddRemoveEditButtonActionPerformed(ActionEvent evt)//GEN-FIRST:event_icpAddRemoveEditButtonActionPerformed
	{//GEN-HEADEREND:event_icpAddRemoveEditButtonActionPerformed
		JDialog listMgr = new IcpListManager(m_ParentFrame,
			(String)icpNameSelect.getSelectedItem(), m_listManagerListener);
	}//GEN-LAST:event_icpAddRemoveEditButtonActionPerformed

	/**
	 * Updates the list of ICPs to reflect the content of the ICP repository.
	 */
	private void updateHostNameField()
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				synchronized(IcpListSelectPanel.this)
				{
					// Remove all change listeners since we are about to change this combo box
					ActionListener[] listeners = icpNameSelect.getActionListeners();
					for( int i = 0; (null != listeners)&&(i < listeners.length); ++i )
					{
						icpNameSelect.removeActionListener(listeners[i]);
					}
	
					icpNameSelect.removeAllItems();
					synchronized(IcpRepository.getInstance())
					{
						if(!IcpRepository.getInstance().isEmpty())
						{
							// Now rebuild the combo box with the content of the ICP desc array
							Iterator iter = IcpRepository.getInstance().getIcpList().iterator();
							m_SortedIcps.clear();
							while( iter.hasNext())
							{
								IcpDescriptor desc = (IcpDescriptor)iter.next();
								m_SortedIcps.put(desc.getName(), desc);
							}
							iter = m_SortedIcps.keySet().iterator();
							while( iter.hasNext())
							{
								icpNameSelect.addItem((String)iter.next());
							}
						}
					}
					// Now put all the listeners back
					if(listeners != null) {
						for( int i = 0; i < listeners.length; ++i )
						{
							icpNameSelect.addActionListener(listeners[i]);
						}
					}
					
					if(null != m_selectedIcpName)
					{
						setSelectedIcp(m_selectedIcpName);
					}
					else
					{
						if(icpNameSelect.getItemCount() > 0)
						{
							icpNameSelect.setSelectedIndex(0);
							m_selectedIcpName = (String)icpNameSelect.getSelectedItem();
						}
						else
							m_selectedIcpName = "";
					}
					repaint();
				}
			}
		});
	}
	
	private void fireListChangeAction(ActionEvent e)
	{
		Set<ActionListener> listeners;
		synchronized(m_actionListeners) {
			listeners = new HashSet<ActionListener>(m_actionListeners);
		}
		Iterator iter = listeners.iterator();
		while(iter.hasNext())
		{
			ActionListener listener = (ActionListener)iter.next();
			listener.actionPerformed(e);
		}
	}
	
	private class IcpListManagerListener implements ListManagerListener
	{
		private IcpListManagerListener()
		{
		}
		
		@Override
		public void onAccept(String selectedIcpName, JDialog thisDialog)
		{
			thisDialog.dispose();
			m_selectedIcpName = selectedIcpName;
			updateHostNameField(); // Rebuild the local ICP list if necesssary
		}
		
		@Override
		public void onCancel(JDialog thisDialog)
		{
			thisDialog.dispose();
			updateHostNameField(); // Rebuild the local ICP list if necesssary
		}
		
	}	
	
	/**
	 * Filters out the combobox's action events which get generated when using the
	 * keyboard to traverse the dropdown list. Only generate event if the dropdown box
	 * is dismissed.
	 */	
	private class FilterComboBoxActionListener implements javax.swing.event.PopupMenuListener, ActionListener
	{
		
		public void popupMenuCanceled(javax.swing.event.PopupMenuEvent popupMenuEvent)
		{
		}
		
		public void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent popupMenuEvent)
		{
			fireListChangeAction(new ActionEvent(popupMenuEvent.getSource(), 0, null));
		}
		
		public void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent popupMenuEvent)
		{
		}
		
		public void actionPerformed(java.awt.event.ActionEvent actionEvent)
		{
			if(!icpNameSelect.isPopupVisible())
				fireListChangeAction(actionEvent);
		}
		
	}
	
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton icpAddRemoveEditButton;
    private javax.swing.JComboBox icpNameSelect;
    // End of variables declaration//GEN-END:variables
	
	private final IcpListManagerListener m_listManagerListener = new IcpListManagerListener();
	private String m_selectedIcpName;
	private final Frame m_ParentFrame;
	
	private final Set<ActionListener> m_actionListeners = new HashSet<ActionListener>();
	
	private final FilterComboBoxActionListener m_filterActionListener = new FilterComboBoxActionListener();

	private final class IcpRepositoryObserver implements IcpRepository.RepositoryObserver
	{
		private IcpRepositoryObserver()
		{
		}
		
		@Override
		public void icpListUpdated(Collection icps)
		{
			updateHostNameField();
		}

		@Override
		public void icpUpdated(IcpDescriptor icp)
		{
			updateHostNameField();
		}

		@Override
		public void icpRemoved(IcpDescriptor icp)
		{
			updateHostNameField();
		}
	}

	private final IcpRepositoryObserver m_IcpRepositpryObserver = new IcpRepositoryObserver();

	private final Map<String, IcpDescriptor> m_SortedIcps = new TreeMap<String, IcpDescriptor>();
}
