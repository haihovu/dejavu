/* Generated by Together */

package com.mitel.icp;

import com.mitel.miutil.MiLogMsg.Category;
import com.mitel.miutil.MiSystem;
import java.util.Collection;
import java.util.List;

/**
 * This class represents the API for an ICP repository implementation.
 */
public abstract class IcpRepository
{
	/**
	 * Default constructor
	 */
	protected IcpRepository()
	{
	}

	/**
	 * Clears the content of this repository and replaces it with the given Vector of ICP's,
	 * in effect reinitializes the repository.
	 * @param icpList The new ICP list with which to reinitialize the local repository.
	 */
	public abstract void setIcpList(List<IcpDescriptor> icpList);

	/**
	 * Retrieves the list of IcpDescriptor objects managed by this component.
	 * @return The list of all ICPs in the repository.
	 * The client may modify the list without affecting the repository,
	 * however modification to the ICPs in the list will reflect in the repository.
	 */	
	public abstract List<IcpDescriptor> getIcpList();

	/**
	 * Locates an ICP from the repository, given its name.
	 * @param icpName Name of the desired ICP.
	 * @return The requested ICP descriptor, or null if no match was found.
	 */
	public abstract IcpDescriptor getIcp(String icpName);

	/**
	 * Adds/Updates an ICP to the repository. 
	 * If the ICP given already exists in the repository, it will be updated, otherwise a new entry is inserted.
	 * @param newIcp The new ICP record to add to the repository.
	 */
	public abstract void setIcp(IcpDescriptor newIcp);

	/**
	 * Removes an ICP from the repository. 
	 * @param icpName The name of the ICP record to remove from the repository.
	 * @throws IcpException
	 */
	public abstract void removeIcp(String icpName) throws IcpException;

	/**
	 * Determine if an ICP (by its name) is in the repository.
	 * @param icpName The name of the ICP in question.
	 * @return
	 */	
	public abstract boolean isIcpInList(String icpName);

	/**
	 * Determines if the repository is empty.
	 * @return
	 */
	public abstract boolean isEmpty();	
	
	public abstract void fireRepositoryUpdateEvent(Collection icpList);
	public abstract void fireRepositoryUpdateEvent(IcpDescriptor icp);
	public abstract void fireRepositoryDeleteEvent(IcpDescriptor icp) throws IcpException;

	public abstract void removeObserver(RepositoryObserver observer);

	public abstract void addObserver(RepositoryObserver observer);

	/**
	 * Acquires the ICP repository singleton, which should be registered previously.
	 * If no repository was registered previously, a default one based on IcpRepositoryDefault will be used.
	 * @return
	 */
	@SuppressWarnings("ResultOfObjectAllocationIgnored")
	public static IcpRepository getInstance()
	{
		synchronized(gLock)
		{
			if(null == gSingleton)
			{
				MiSystem.logWarning(Category.DESIGN,
					"Using the default repository implementation.");

				gSingleton = new IcpRepositoryDefault();
			}
			return gSingleton;
		}
	}	

	/**
	 * Registers a concrete ICP repository singleton.
	 * @param newRepository The new repository instance to be used as the singleton.
	 */
	public static void registerRepository(IcpRepository newRepository)
	{
		synchronized(gLock)
		{
			gSingleton = newRepository;
		}
	}

	/**
	 * Observer/Listener interface for clients of the ICP repository.
	 */
	public interface RepositoryObserver
	{
		/**
		 * The ICP list had been updated inside the repository
		 * @param icps The updated list of ICPs.
		 */
		public abstract void icpListUpdated(Collection icps);
		/**
		 * An ICP had been updated inside the repository.
		 * @param icp The descriptor identifying the ICP that was updated.
		 */
		public abstract void icpUpdated(IcpDescriptor icp);
		/**
		 * An ICP had been icpRemoved from the repository.
		 * @param icp The descriptor identifying the ICP that was icpRemoved.
		 * @throws IcpException
		 */
		public abstract void icpRemoved(IcpDescriptor icp) throws IcpException;
	}

	/**
	 * @supplierCardinality 1 
	 */
	private static IcpRepository gSingleton;
	private static final Object gLock = new Object();
}
