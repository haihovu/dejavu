/* Generated by Together */

package org.dejavu.activefx;

import org.dejavu.util.DjvExceptionUtil;
import org.dejavu.util.DjvLogMsg.Category;
import org.dejavu.util.DjvSystem;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;

/**
 * Object-oriented analog to a server port listening to connection request from clients via the accept() method.
 * Acceptors are typically used by server applications to accept and handle clients connection requests.
 */
public class AfxAcceptor
{
	/**
	 * Creates an acceptor associated with a particular Active FX domain.
	 * @param domain The Active FX domain that the new acceptor belongs to.
	 */
	public AfxAcceptor(AfxDomain domain)
	{
		m_Domain = domain;
	}

	/**
	 * Opens an acceptor, binding it to a local server port.
	 * This must be done before invoking accept().
	 * @param ipAddr The local network interface to bind to, typically 127.0.0.1.
	 * @param ipPort The server port to bind to.
	 * @param eventHandler The handler with which to receive accept events.
	 * @return True if the acceptor was successfully opened, false otherwise.
	 */
	public synchronized boolean open(String ipAddr, int ipPort, AfxEventHandler eventHandler)
	{
		try
		{
			if(m_State == ACCEPTOR_STATE_CLOSED)
			{
				m_Channel = ServerSocketChannel.open();
				m_Channel.configureBlocking(false);
				m_Channel.socket().bind(new InetSocketAddress( ipPort) ) ;  // EB: changed from: ( ipAddr, ipPort) since it is local anyway
				m_EventHandler = eventHandler;
				m_State = ACCEPTOR_STATE_IDLE;
				return true;
			}
		}
		catch(Exception e)
		{
			DjvSystem.logError(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
		}
		return false;
	}

	/**
	 * Closes an acceptor, releasing all resources acquired in open().
	 *
	 * @return True if the acceptor was successfully closed, false otherwise
	 */
	public synchronized boolean close( )
	{
		try
		{
			if(m_State != ACCEPTOR_STATE_CLOSED)
			{
				m_Domain.deregisterHandler(m_AcceptEventHandler, SelectionKey.OP_ACCEPT);
				m_Channel.close();
				m_State = ACCEPTOR_STATE_CLOSED;
				m_EventHandler = null;
				return true;
			}
		}
		catch(Exception e)
		{
			DjvSystem.logError(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
		}
		return false;
	}

	/**
	 * Initiates the acceptance of connection requests.
	 * Must first open the acceptor prior to invoking this.
	 * This is an asynchronous invocation, i.e. it returns immediately.
	 * Connection request events will be delivered, asynchronously, as they come in, 
	 * via the event handler given in the open command.
	 *
	 * @return True if the accept handled had been successfully registered, we're now
	 * listening for accept events, or false means the accept handler was not registered.
	 */
	public synchronized boolean accept()
	{
		try
		{
			if(m_State == ACCEPTOR_STATE_IDLE)
			{
				m_State = ACCEPTOR_STATE_ACCEPTING;
				m_Domain.registerHandler(m_AcceptEventHandler, java.nio.channels.SelectionKey.OP_ACCEPT);
				return true;
			}
			throw new RuntimeException("Acceptor in wrong state " + m_State);
		}
		catch(RuntimeException e)
		{
			DjvSystem.logError(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
		}
		return false;
	}

	private static final int ACCEPTOR_STATE_CLOSED = 1;
	private static final int ACCEPTOR_STATE_IDLE = 2;
	private static final int ACCEPTOR_STATE_ACCEPTING = 3;
	
	private volatile ServerSocketChannel m_Channel;
	
	/**
	 * The domain governing this acceptor
	 */
	private final AfxDomain m_Domain;

	/**
	 * The event handler, given with the previous open invocation
	 */
	private AfxEventHandler m_EventHandler;
	/**
	 * Simple state machine.
	 */
	private volatile int m_State = ACCEPTOR_STATE_CLOSED;
	private final AcceptEventHandler m_AcceptEventHandler = new AcceptEventHandler();
	
	/**
	 * Reactor event handler for this acceptor.
	 */
	private final class AcceptEventHandler implements org.dejavu.activefx.ReactorEventHandler
	{
		/**
		 * Creates a new accept event handler
		 */
		private AcceptEventHandler() {
			super();
		}
		
		@Override
		public void onWrite()
		{
			DjvSystem.logError(Category.DESIGN, "Invoked unexpectedly");
		}

		@Override
		public void onRead()
		{
			DjvSystem.logError(Category.DESIGN, "Invoked unexpectedly");
		}

		@Override
		public void onDisconnect()
		{
			DjvSystem.logError(Category.DESIGN, "Invoked unexpectedly");
		}

		@Override
		public void onConnect()
		{
			DjvSystem.logError(Category.DESIGN, "Invoked unexpectedly");
		}

		@Override
		public void onAccept()
		{
			AfxEventHandler handler;
			synchronized(AfxAcceptor.this) {
				// Set the state before executing the callback
				handler = m_EventHandler;
				m_State = ACCEPTOR_STATE_IDLE;
			}
			
			try
			{
				
				// Only accept TCP connection for now
				SocketChannel newChannel = m_Channel.accept();
				m_Domain.deregisterHandler(this, java.nio.channels.SelectionKey.OP_ACCEPT);
				if(null != newChannel)
				{
					newChannel.configureBlocking( false );
					Socket sock = newChannel.socket() ;
					sock.setKeepAlive( true ) ;
					if(null != handler)
					{
						handler.acceptCompleted(newChannel);
					}
				}
			}
			catch(RuntimeException e)
			{
				DjvSystem.logError(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
			}
			catch(IOException ex) {
				DjvSystem.logError(Category.DESIGN, DjvExceptionUtil.simpleTrace(ex));
			}
		}

		@Override
		public SelectableChannel getHandle()
		{
			return m_Channel;
		}
	}

}
