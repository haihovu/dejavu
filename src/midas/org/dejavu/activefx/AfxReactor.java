/* Generated by Together */

package org.dejavu.activefx;

import org.dejavu.util.DjvExceptionUtil;
import org.dejavu.util.DjvLogMsg.Category;
import org.dejavu.util.DjvSystem;
import java.io.IOException;
import java.nio.channels.*;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Set;

/**
 * The central concept of the Reactor pattern.
 * These are active objects that detects read/write/connect events on a number of registered channels.
 * Events are dispatched to the registered event handlers for processing.
 */
class AfxReactor implements Runnable
{
	/**
	 * Creates a new Active FX reactor.
	 * @param name The name of the reactor to be created.
	 * @throws IOException 
	 */
	AfxReactor(String name) throws IOException
	{
		m_Name = name;
		m_MaxChannels = 5120;
		m_Selector = Selector.open();
	}

	/**
	 * Creates a new Active FX reactor.
	 * @param name The name of the reactor to be created.
	 * @param maxChannels The maximum number of channels that can be supported by this reactor.
	 * @throws IOException 
	 */
	AfxReactor(String name, int maxChannels) throws IOException
	{
		m_Name = name;
		m_MaxChannels = maxChannels;
		m_Selector = Selector.open();
	}

	/**
	 * Retrieves the set of interested operation for a specific handler
	 * @param handler The target handler
	 * @return The interested operation associated with the given handler. Basically a bit map of
	 * the different OP values in the class SelectionKey.
	 */
	public synchronized int getInterestOpsFor(ReactorEventHandler handler) {
		m_Selector.wakeup();
		SelectableChannel channel = handler.getHandle();
		SelectionKey key = channel != null ? channel.keyFor(m_Selector) : null;
		if(key != null) {
			if(key.isValid()) {
				return key.interestOps();
			}
		}
		return 0;
	}
	
	/**
	 * Retrieves the set of ready operation for a specific handler
	 * @param handler The target handler
	 * @return The ready operation associated with the given handler. Basically a bit map of
	 * the different OP values in the class SelectionKey.
	 */
	public synchronized int getReadyOpsFor(ReactorEventHandler handler) {
		m_Selector.wakeup();
		SelectableChannel channel = handler.getHandle();
		SelectionKey key = channel != null ? channel.keyFor(m_Selector) : null;
		if(key != null) {
			if(key.isValid()) {
				return key.readyOps();
			}
		}
		return 0;
	}
	
	/**
	 * Registers an event handler with the reactor.
	 * @param handler The event handler to be registered
	 * @param events The set of interested events (bit-masked of SelectionKey OP flags).
	 */
	public synchronized void registerHandler(ReactorEventHandler handler, int events)
	{
		try
		{
			// Because Selector.select() actually synchronizes on the key set, we
			// must break it out so that the logic below won't block
			m_Selector.wakeup();

			SelectionKey key = handler.getHandle().keyFor(m_Selector);
			if((null == key)||(!key.isValid()))
			{
				if(0 != events)
				{
					if(null != key)
					{
						// Forcibly invoking select to clear all canceled keys
						// otherwise the regiter method will throw cancelled key exception
						try{m_Selector.selectNow();}catch(IOException e){}

						// selectNow clears the effect of any previous wakeup
						m_Selector.wakeup();
					}
					key = handler.getHandle().register(m_Selector, events);
					if(null != key)
					{
						key.attach(handler);
					}
					else
					{
						DjvSystem.logError(Category.DESIGN,
							"Failed to register " + handler + " with selector");
					}
				}
			}
			else
			{
				int originalOps = key.interestOps();
				int interestOps = originalOps | events;
				if(interestOps != 0)
				{
					if(interestOps != originalOps) // Only modify interest ops if something changes.
					{
						key.interestOps(interestOps);
					}
					else
					{
						DjvSystem.logInfo(Category.DESIGN,
							"Already registered for " + events + " @ " + DjvExceptionUtil.getCompressedTrace());
					}
				}
				else
				{
					key.cancel();
				}
			}
		}
		catch(java.nio.channels.ClosedChannelException e)
		{
			DjvSystem.logError(Category.DESIGN,
				"Channel " + handler.getHandle() + " closed");
		}
		catch(CancelledKeyException e)
		{
			DjvSystem.logError(Category.DESIGN,
				"Channel " + handler.getHandle() + " encountered cancelled key @ " + DjvExceptionUtil.simpleTrace(e));
		}
	}

	/**
	 * Deregisters an event handler from the reactor against some set of events.
	 * If the specified handler is still registered against some other events it will continue to be served by the reactor.
	 * @param handler The event handler to deregister.
	 * @param events The set of events to remove
	 */
	public synchronized void deregisterHandler(ReactorEventHandler handler, int events)
	{
		if(null != handler.getHandle())
		{
			// Cancelled keys and changed interest set are not reflected until select() is invoked again
			m_Selector.wakeup();

			SelectionKey key = handler.getHandle().keyFor(m_Selector);
			if((null != key)&&(key.isValid()))
			{
				// Remove the unwanted bits from the existing interest OPs
				int interestOps = key.interestOps() & (~events);

				if(0 == interestOps)
				{
					key.cancel();
				}
				else if(interestOps != key.interestOps()) // Only modify interest ops if something changes
				{
					key.interestOps(interestOps);
				}
			}
			else
				DjvSystem.logError(Category.DESIGN, "Invalid key");
		}
		else
		{
			DjvSystem.logError(Category.DESIGN, "Null handle");
		}
	}

	/**
	 * Remove an event handler from the reactor no matter if it is still registered with some set of events.
	 * This is equivalent to deregistering the handler against all events.
	 * @param handler The event handler to remove.
	 */
	public synchronized void removeHandler(ReactorEventHandler handler)
	{
		if(null != handler.getHandle())
		{
			m_Selector.wakeup();
			SelectionKey key = handler.getHandle().keyFor(m_Selector);
			if((null != key)&&(key.isValid()))
			{
				key.cancel();
			}
		}
	}

	@Override
	@SuppressWarnings({"NestedAssignment", "EmptySynchronizedStatement"})
	public void run()
	{
		// Support for 5120 sockets
		int[] interestArray = new int[m_MaxChannels];
		ReactorEventHandler[] handlerArray = new ReactorEventHandler[m_MaxChannels];
		SelectableChannel[] channelArray = new SelectableChannel[m_MaxChannels];

		try
		{
			while(m_bRunning)
			{
				// Allows this thread to be blocked (by deregister/registerHandler)
				// prior to re-entering into select()
				synchronized(this){}

				if(m_Selector.select() > 0)
				{
					int keyCount = 0;

					// Extract all key info inside this synchronized block to prevent deadlock
					synchronized(this)
					{
						Set<SelectionKey> selectedKeys = m_Selector.selectedKeys();
						for(SelectionKey key : selectedKeys)
						{
							if(key.isValid())
							{
								if(keyCount < m_MaxChannels)
								{
									channelArray[keyCount] = key.channel();
									interestArray[keyCount] = key.readyOps();
									handlerArray[keyCount++] = (ReactorEventHandler)key.attachment();
								}
								else
								{
									DjvSystem.logError(Category.DESIGN,
										m_Name + ": number of channels, " + selectedKeys.size() + " exceeded maximum of " + m_MaxChannels);
								}
							}
						}
						selectedKeys.clear();
					}

					for(int i = 0; i < keyCount; ++i)
					{
						int interest = interestArray[i];
						ReactorEventHandler handler = handlerArray[i];
						if(null != handler)
						{
							if(!channelArray[i].isOpen())
							{
								handler.onDisconnect();
							}
							else
							{
								if(0 != (interest & SelectionKey.OP_CONNECT))
									handler.onConnect();

								if(0 != (interest & SelectionKey.OP_READ))
									handler.onRead();

								if(0 != (interest & SelectionKey.OP_WRITE))
									handler.onWrite();

								if(0 != (interest & SelectionKey.OP_ACCEPT))
									handler.onAccept();
							}
						}

						handlerArray[i] = null;
						channelArray[i] = null;
					}
				}
				else
				{
					synchronized(this)
					{
						if(!m_Selector.isOpen())
							break;
					}
				}
			}
		} catch(IOException e) {
			DjvSystem.logWarning(Category.DESIGN, this + " terminated due to " 
				+ DjvExceptionUtil.simpleTrace(e));
		} catch(RuntimeException e) {
			DjvSystem.logError(Category.DESIGN, this + " terminated due to " 
				+ DjvExceptionUtil.simpleTrace(e));
		} finally {
			try {
				m_Selector.close();
			}
			catch(IOException ex) {
			}
		}
	}

	/**
	 * Starts the reactor, spawning its active thread.
	 * @param threadPriority The priority of the reactor thread. An integer in the range of
	 * Thread.MIN_PRIORITY(1)-Thread.MAX_PRIORITY(10). Use zero or other values outside
	 * the valid range to denote default priority (same priority as calling thread).
	 */
	public synchronized void start(int threadPriority)
	{
		if(!m_bStarted)
		{
			m_bStarted = true;
			Thread myThread = new Thread(this, m_Name + "Reactor");
			if((threadPriority >= Thread.MIN_PRIORITY)&&(threadPriority <= Thread.MAX_PRIORITY)) {
				myThread.setPriority(threadPriority);
			}
			myThread.start();
		}
	}

	/**
	 * Stops the reactor, destroying its active thread.
	 * Once stopped the reactor should be discarded and not be reused.
	 */
	public void stop()
	{
		try
		{
			m_bRunning = false;
			m_Selector.close();
		}
		catch(IOException e)
		{
			DjvSystem.logWarning(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
		}
	}

	@Override
	public String toString() {
		synchronized(this) {
			return "AfxReactor: {" + "selector:" + m_Selector + ", started:" + m_bStarted + ", running:" + m_bRunning + ", name:" + m_Name + ", maxChannels:" + m_MaxChannels + '}';
		}
	}

	private final Selector m_Selector;
	private boolean m_bStarted = false;
	private boolean m_bRunning = true;
	
	/** @link dependency */
    /*# ReactorEventHandler lnkReactorEventHandler; */

	/** @link dependency */
    /*# AfxException lnkAfxException; */

	private final String m_Name;

	private final int m_MaxChannels;
}
