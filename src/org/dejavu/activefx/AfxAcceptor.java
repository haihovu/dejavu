/* Generated by Together */
package org.dejavu.activefx;

import org.dejavu.util.DjvExceptionUtil;
import org.dejavu.util.DjvLogMsg.Category;
import org.dejavu.util.DjvSystem;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;

/**
 * Object-oriented analog to a server port listening to connection request from
 * clients via the accept() method. Acceptors are typically used by server
 * applications to accept and handle clients connection requests.
 */
public class AfxAcceptor {

	/**
	 * Creates an acceptor associated with a particular Active FX domain.
	 *
	 * @param domain The Active FX domain that the new acceptor belongs to.
	 * @param eventHandler
	 * @throws java.io.IOException
	 */
	public AfxAcceptor(AfxDomain domain, AfxEventHandler eventHandler) throws IOException {
		this.domain = domain;
		channel = ServerSocketChannel.open();
		this.eventHandler = eventHandler;
	}

	/**
	 * Opens an acceptor, binding it to a local server port. This must be done
	 * before invoking accept().
	 *
	 * @param ipAddr The local network interface to bind to, typically
	 * 127.0.0.1.
	 * @param ipPort The server port to bind to.
	 * @throws java.io.IOException Failed to open listening socket
	 */
	public synchronized void open(String ipAddr, int ipPort) throws IOException {
		if (currentState == State.ACCEPTOR_STATE_CLOSED) {
			channel.configureBlocking(false);
			channel.socket().bind(new InetSocketAddress(ipPort));  // EB: changed from: ( ipAddr, ipPort) since it is local anyway
			currentState = State.ACCEPTOR_STATE_IDLE;
		}
	}

	/**
	 * Closes an acceptor, releasing all resources acquired in open().
	 */
	public synchronized void close() {
		try {
			if (currentState != State.ACCEPTOR_STATE_CLOSED) {
				domain.deregisterHandler(acceptEventHandler, SelectionKey.OP_ACCEPT);
				channel.close();
				currentState = State.ACCEPTOR_STATE_CLOSED;
			}
		} catch (IOException e) {
			DjvSystem.logWarning(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
		}
	}

	/**
	 * Initiates the acceptance of connection requests. Must first open the
	 * acceptor prior to invoking this. This is an asynchronous invocation, i.e.
	 * it returns immediately. Connection request events will be delivered,
	 * asynchronously, as they come in, via the event handler given in the open
	 * command.
	 *
	 * @throws org.dejavu.activefx.AfxException
	 */
	public synchronized void accept() throws AfxException {
		try {
			if (currentState == State.ACCEPTOR_STATE_IDLE) {
				currentState = State.ACCEPTOR_STATE_ACCEPTING;
				domain.registerHandler(acceptEventHandler, java.nio.channels.SelectionKey.OP_ACCEPT);
			} else {
				throw new AfxException("Acceptor in wrong state " + currentState);
			}
		} catch (RuntimeException e) {
			throw new AfxException("Accept Failed", e);
		}
	}

	/**
	 * Acceptors' states
	 */
	public static enum State {
		ACCEPTOR_STATE_CLOSED,
		ACCEPTOR_STATE_IDLE,
		ACCEPTOR_STATE_ACCEPTING
	}

	private final ServerSocketChannel channel;

	/**
	 * The domain governing this acceptor
	 */
	private final AfxDomain domain;

	/**
	 * The event handler, given with the previous open invocation
	 */
	private final AfxEventHandler eventHandler;
	/**
	 * Simple state machine.
	 */
	private State currentState = State.ACCEPTOR_STATE_CLOSED;
	private final AcceptEventHandler acceptEventHandler = new AcceptEventHandler();

	/**
	 * Reactor event handler for this acceptor.
	 */
	private final class AcceptEventHandler implements org.dejavu.activefx.ReactorEventHandler {

		/**
		 * Creates a new accept event handler
		 */
		private AcceptEventHandler() {
			super();
		}

		@Override
		public void onWrite() {
			DjvSystem.logError(Category.DESIGN, "Invoked unexpectedly");
		}

		@Override
		public void onRead() {
			DjvSystem.logError(Category.DESIGN, "Invoked unexpectedly");
		}

		@Override
		public void onDisconnect() {
			DjvSystem.logError(Category.DESIGN, "Invoked unexpectedly");
		}

		@Override
		public void onConnect() {
			DjvSystem.logError(Category.DESIGN, "Invoked unexpectedly");
		}

		@Override
		public void onAccept() {
			synchronized (AfxAcceptor.this) {
				// Set the state before executing the callback
				currentState = State.ACCEPTOR_STATE_IDLE;
			}

			try {
				// Only accept TCP connection for now
				SocketChannel newChannel = channel.accept();
				// Why?
				//domain.deregisterHandler(this, java.nio.channels.SelectionKey.OP_ACCEPT);
				if (null != newChannel) {
					newChannel.configureBlocking(false);
					Socket sock = newChannel.socket();
					sock.setKeepAlive(true);
					if (null != eventHandler) {
						eventHandler.acceptCompleted(newChannel);
					}
				}
			} catch (RuntimeException | IOException e) {
				DjvSystem.logError(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
			}
		}

		@Override
		public SelectableChannel getHandle() {
			synchronized(AfxAcceptor.this) {
				return channel;
			}
		}
	}
}
