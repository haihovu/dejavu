/* Generated by Together */
package org.dejavu.activefx;

import org.dejavu.fsm.FsmContext;
import org.dejavu.fsm.FsmEvent;
import java.nio.ByteBuffer;
import java.nio.channels.SelectableChannel;

/**
 * Represents FSM events for use in the Active FX framework. Each AfxFsmEvent
 * object can have a number of optional attributes:
 * <ul>
 * <li>Buffer</li>
 * <li>Cause</li>
 * <li>Channel</li>
 * <li>Event Handler</li>
 * <li>IP Address</li>
 * <li>IP Port</li>
 * </ul>
 */
class AfxFsmEvent implements FsmEvent {

	/**
	 * Open channel request.
	 */
	static final int OPEN = 1;
	/**
	 * Close channel request.
	 */
	static final int CLOSE = 2;
	/**
	 * Initiate read request.
	 */
	final static int READ = 3;
	/**
	 * Initiate write request.
	 */
	final static int WRITE = 4;
	/**
	 * Read attempt failed
	 */
	final static int READ_FAILURE = 5;
	/**
	 * Write attempt failed
	 */
	final static int WRITE_FAILURE = 6;
	/**
	 * Open attempt failed
	 */
	final static int OPEN_FAILURE = 7;
	/**
	 * Read completed successfully
	 */
	final static int READ_COMPLETE = 8;
	/**
	 * Write completed successfully
	 */
	final static int WRITE_COMPLETE = 9;
	/**
	 * Open completed successfully
	 */
	final static int OPEN_COMPLETE = 10;
	/**
	 * Close completed successfully
	 */
	final static int CLOSE_COMPLETE = 11;
	/**
	 * Channel ready for reading
	 */
	final static int ON_READ = 12;
	/**
	 * Channel ready for writing
	 */
	final static int ON_WRITE = 13;
	/**
	 * Initiate hand shaking
	 */
	final static int HANDSHAKE = 14;
	/**
	 * Perform watchdog checks.
	 */
	final static int WATCHDOG_CHECK = 15;
	/**
	 * For Registering a ServerSocketAccept
	 */
	final static int CONNECT = 16;

	/**
	 * Creates a new AfxFsmEvent, for general usage.
	 *
	 * @param id The event ID
	 * @param context The FSM context to receive this event
	 */
	AfxFsmEvent(int id, FsmContext context) {
		this.id = id;
		this.context = context;
		channel = null;
		ipPort = -1;
		ipAddr = null;
	}

	/**
	 * Creates a new AfxFsmEvent, for failure notification.
	 *
	 * @param id The event ID
	 * @param context The FSM context to receive this event
	 * @param cause The failure cause
	 */
	AfxFsmEvent(int id, FsmContext context, String cause) {
		this.id = id;
		this.cause = cause;
		this.context = context;
		channel = null;
		ipPort = -1;
		ipAddr = null;
	}

	/**
	 * Creates a new AfxFsmEvent, for use with open requests.
	 *
	 * @param id The event ID
	 * @param context The FSM context to receive this event
	 * @param ipAddr The IP address of the remote endpoint with which to
	 * initiate the connection.
	 * @param ipPort The IP port of the remote endpoint with which to inititate
	 * the connection
	 * @param handler The interface to the callback object for receiving
	 * connection events.
	 */
	AfxFsmEvent(int id, FsmContext context, String ipAddr, int ipPort, AfxEventHandler handler) {
		this.id = id;
		this.context = context;
		this.ipAddr = ipAddr;
		this.ipPort = ipPort;
		eventHandler = handler;
		channel = null;
	}

	/**
	 * Creates a new AfxFsmEvent, for use with read/write requests.
	 *
	 * @param id The event ID
	 * @param context The FSM context to receive this event
	 * @param buffer The byte buffer to be used in the read/write requests.
	 * @param handler The interface to the callback object for receiving
	 * read/write events.
	 */
	AfxFsmEvent(int id, FsmContext context, ByteBuffer buffer, AfxEventHandler handler) {
		this.id = id;
		this.context = context;
		this.buffer = buffer;
		eventHandler = handler;
		channel = null;
		ipPort = -1;
		ipAddr = null;
	}

	/**
	 * Creates a new AfxFsmEvent, for use with open requests.
	 *
	 * @param id The event ID
	 * @param context The FSM context to receive this event
	 * @param channel An I/O channel to be used for establishing the connection.
	 * @param handler The interface to the callback object for receiving
	 * connection events.
	 */
	AfxFsmEvent(int id, FsmContext context, SelectableChannel channel, AfxEventHandler handler) {
		this.id = id;
		this.context = context;
		this.channel = channel;
		eventHandler = handler;
		ipPort = -1;
		ipAddr = null;
	}

	/**
	 * Retrieves the <I>Cause</I> attribute. This attribute is set once in one
	 * of the constructors.
	 *
	 * @return The string representing the <I>Cause</I> attribute, null if not
	 * set.
	 */
	public String getCause() {
		return cause;
	}

	/**
	 * Retrieves the <I>Buffer</I> attribute. This attribute is set once in one
	 * of the constructors.
	 *
	 * @return The byte buffer representing the <I>Buffer</I> attribute, null if
	 * not set.
	 */
	public ByteBuffer getBuffer() {
		return buffer;
	}

	/**
	 * Retrieves the <I>Event Handler</I> attribute. This attribute is set once
	 * in one of the constructors.
	 *
	 * @return The object representing the <I>Event Handler</I> attribute, null
	 * if not set.
	 */
	public AfxEventHandler getEventHandler() {
		return eventHandler;
	}

	@Override
	public String toString() {
		StringBuilder retValue = new StringBuilder(64);
		switch (id) {
			case OPEN:
				retValue.append("OPEN");
				break;
			case CLOSE:
				retValue.append("CLOSE");
				break;
			case READ:
				retValue.append("READ");
				break;
			case WRITE:
				retValue.append("WRITE");
				break;
			case READ_FAILURE:
				retValue.append("READ_FAILURE");
				break;
			case WRITE_FAILURE:
				retValue.append("WRITE_FAILURE");
				break;
			case OPEN_FAILURE:
				retValue.append("OPEN_FAILURE");
				break;
			case READ_COMPLETE:
				retValue.append("READ_COMPLETE");
				break;
			case WRITE_COMPLETE:
				retValue.append("WRITE_COMPLETE");
				break;
			case OPEN_COMPLETE:
				retValue.append("OPEN_COMPLETE");
				break;
			case CLOSE_COMPLETE:
				retValue.append("CLOSE_COMPLETE");
				break;
			case HANDSHAKE:
				retValue.append("HANDSHAKE");
				break;
			case CONNECT:
				retValue.append("CONNECT");
				break;
			default:
				retValue.append("UNKNOWN");
		}

		return retValue.append(".").append(ipAddr).append(":").append(ipPort).toString();
	}

	@Override
	public FsmContext getContext() {
		return context;
	}

	@Override
	public int getId() {
		return id;
	}

	/**
	 * @supplierCardinality 1
	 */
	public final FsmContext context;
	public final SelectableChannel channel;
	public final int id;
	public final String ipAddr;
	public final int ipPort;
	
	private String cause;
	private ByteBuffer buffer = null;

	/**
	 * @supplierCardinality 1
	 */
	private AfxEventHandler eventHandler = null;
}
