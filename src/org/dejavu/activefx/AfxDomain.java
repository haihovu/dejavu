/* Generated by Together */
package org.dejavu.activefx;

import org.dejavu.fsm.FsmException;
import org.dejavu.util.DjvWatchDog;
import java.io.IOException;
import org.dejavu.fsm.FsmEvent;
import org.dejavu.fsm.FsmState;
import org.dejavu.fsm.FsmDomain;
import org.dejavu.util.DjvLogMsg;
import org.dejavu.util.DjvSystem;

/**
 * The engine of the Active FX framework, built on the MiFsm framework.
 */
public class AfxDomain {

	/**
	 * Creates a new instance of the Active FX engine.
	 *
	 * @param name The name of this instance.
	 * @throws FsmException
	 */
	public AfxDomain(String name) throws FsmException {
		fsmDomain = new AfxConnectionFsmDomain(name);
		this.name = name;
	}

	/**
	 * Starts Active FX engine, without watchdog monitoring.
	 *
	 * @param maxChannels The maximum number of channels supported. This allow
	 * the domain to limit the amount of resource allocated.
	 * @param reactorThreadPriority The priority of the reactor thread. Valid
	 * values are integers in the range of
	 * Thread.MIN_PRIORITY(1)-Thread.MAX_PRIORITY(10). Use values outside the
	 * valid range to denote default priority (same priority as calling thread).
	 * @throws IOException
	 */
	public void start(int maxChannels, int reactorThreadPriority) throws IOException {
		fsmDomain.start(null, -1, null);
		synchronized (this) {
			if (null == reactor) {
				reactor = new AfxReactor(name, maxChannels);
				reactor.start(reactorThreadPriority);
			}
		}
	}

	/**
	 * Starts Active FX engine, with watchdog monitoring.
	 *
	 * @param maxChannels The maximum number of channels supported. This allow
	 * the domain to limit the amount of resource allocated.
	 * @param watchdog Watchdog with which to monitor this Active FX engine.
	 * @param wdPeriod Watchdog status reporting intervals, in milliseconds.
	 * Only has meaning if a watchdog is given.
	 * @param failureResponse Optional failure response logic, to be invoked if
	 * the watchdog detects a failure with this Active FX engine.
	 * @param reactorThreadPriority The priority of the reactor thread. Valid
	 * values are integers in the range of
	 * Thread.MIN_PRIORITY(1)-Thread.MAX_PRIORITY(10). Use values outside the
	 * valid range to denote default priority (same priority as calling thread).
	 * @throws IOException
	 */
	public void start(int maxChannels, DjvWatchDog watchdog, int wdPeriod, Runnable failureResponse, int reactorThreadPriority) throws IOException {
		fsmDomain.start(watchdog, wdPeriod, failureResponse);
		synchronized (this) {
			if (reactor == null) {
				reactor = new AfxReactor(name, maxChannels);
				reactor.start(reactorThreadPriority);
			}
		}
	}

	/**
	 * Stops this Active FX engine.
	 */
	public void stop() {
		synchronized (this) {
			if (null != reactor) {
				reactor.stop();
				reactor = null;
			}
		}
		fsmDomain.stop();
	}

	/**
	 * Dispatches an FSM event to the Active FX FSM domain. Intended to be used
	 * internally by other Active FX components.
	 *
	 * @param event The event to dispatch.
	 * @param queued Whether the event to be queued up to be processed by the
	 * FSM domain, or executed immediately by the calling thread.
	 * @return True if the event had either been queued up, or already processed
	 * (queued = false). False if the event cannot be dispatched for any reason.
	 * @throws java.lang.InterruptedException User interruption
	 */
	boolean dispatchEvent(FsmEvent event, boolean queued) throws InterruptedException {
		return fsmDomain.dispatchEvent(event, queued);
	}

	/**
	 * Used internally by the Active FX framework to retrieve the initial state
	 * for each Active FX FSM context.
	 *
	 * @return The initial state for the Active FX FSM context.
	 */
	FsmState getInitialState() {
		return fsmDomain.getInitialState();
	}

	/**
	 * Used internally by the Active FX framework to retrieve the FSM domain for
	 * this particular Active FX engine.
	 *
	 * @return The FSM domain for this engine, never null.
	 */
	FsmDomain getFsmDomain() {
		return fsmDomain;
	}

	/**
	 * Retrieves the set of interested operations (from the reactor) for a
	 * specific handler
	 *
	 * @param handler The target handler
	 * @return The interest operation associated with the given handler.
	 * Basically a bit map of the different OP values in the class SelectionKey.
	 */
	int getInterestOps(ReactorEventHandler handler) {
		AfxReactor tsReactor;
		synchronized (this) {
			tsReactor = this.reactor;
		}
		if (tsReactor != null) {
			return tsReactor.getInterestOpsFor(handler);
		} else {
			DjvSystem.logError(DjvLogMsg.Category.DESIGN, "No reactor");
		}
		return 0;
	}

	/**
	 * Retrieves the set of ready operations (from the reactor) for a specific
	 * handler
	 *
	 * @param handler The target handler
	 * @return The ready operation associated with the given handler. Basically
	 * a bit map of the different OP values in the class SelectionKey.
	 */
	int getReadyOps(ReactorEventHandler handler) {
		AfxReactor tsReactor;
		synchronized (this) {
			tsReactor = this.reactor;
		}
		if (tsReactor != null) {
			return tsReactor.getReadyOpsFor(handler);
		} else {
			DjvSystem.logError(DjvLogMsg.Category.DESIGN, "No reactor");
		}
		return 0;
	}

	/**
	 * Registers a specific handler for some set of operations, against the
	 * reactor.
	 *
	 * @param handler The target handler
	 * @param events The set of operations of interest, basically a bit map of
	 * the different OP values in the class SelectionKey.
	 */
	void registerHandler(ReactorEventHandler handler, int events) {
		AfxReactor tsReactor;
		synchronized (this) {
			tsReactor = this.reactor;
		}
		if (tsReactor != null) {
			tsReactor.registerHandler(handler, events);
		} else {
			DjvSystem.logError(DjvLogMsg.Category.DESIGN, "No reactor");
		}
	}

	/**
	 * De-registers some set of operations from a specific handler, against the
	 * reactor.
	 *
	 * @param handler The target handler
	 * @param events The set of operations of interest, basically a bit map of
	 * the different OP values in the class SelectionKey.
	 */
	void deregisterHandler(ReactorEventHandler handler, int events) {
		AfxReactor tsReactor;
		synchronized (this) {
			tsReactor = this.reactor;
		}
		if (tsReactor != null) {
			tsReactor.deregisterHandler(handler, events);
		}
	}

	/**
	 * Removes a handler from the reactor. Thread-safe.
	 *
	 * @param handler Handler to be removed.
	 */
	void removeHandler(ReactorEventHandler handler) {
		AfxReactor tsReactor;
		synchronized (this) {
			tsReactor = this.reactor;
		}
		if (tsReactor != null) {
			tsReactor.removeHandler(handler);
		}
	}

	/**
	 * @link aggregation
	 * @supplierCardinality 1
	 */
	private AfxReactor reactor;

	/**
	 * @supplierCardinality 1
	 * @link aggregation
	 */
	private final AfxConnectionFsmDomain fsmDomain;
	private final String name;
}
