/* Generated by Together */
package org.dejavu.activefx;

import org.dejavu.fsm.FsmEvent;
import org.dejavu.util.DjvExceptionUtil;
import org.dejavu.util.DjvLogMsg.Category;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLSession;
import org.dejavu.util.DjvSystem;
import org.dejavu.netutil.DjvSocketSslFactory;
import java.net.ConnectException;

public class AfxConnectionTLS extends AfxConnectionTcp {

	private final SSLEngine sslEngine;
	private final int minAppBufferSize;
	private final int minNetBufferSize;
	private final ByteBuffer outNetBuffer;

	public AfxConnectionTLS(AfxDomain domain) throws SSLException {
		super(domain);

		if (null == gSslContext) {
			gSslContext = DjvSocketSslFactory.getInstance().getSslContext();
		}

		sslEngine = gSslContext.createSSLEngine();
		sslEngine.setUseClientMode(true);

		SSLSession session = sslEngine.getSession();
		minAppBufferSize = session.getApplicationBufferSize();
		minNetBufferSize = session.getPacketBufferSize();

		outNetBuffer = ByteBuffer.allocateDirect(minNetBufferSize);
		outNetBuffer.position(outNetBuffer.limit()); // Empty buffer

		inNetBuffer = ByteBuffer.allocateDirect(minNetBufferSize);
		inNetBuffer.position(inNetBuffer.limit()); // Empty buffer

		// The reason we have to add some extra room in here is that unwrap
		// looks for at least m_MinAppBufferSize remaining on the destination
		// buffer before proceeding, which is completely stupid
		inAppBuffer = ByteBuffer.allocate(minAppBufferSize + 10240);
		inAppBuffer.position(inAppBuffer.limit()); // Empty buffer
	}

	@Override
	public int getConnectionType() {
		return AfxConnection.AFX_CONNECTION_TLS;
	}

	@Override
	public void initiateClose(FsmEvent evt) {
		closingHandshake();
	}

	@Override
	public synchronized void initiateRead(FsmEvent evt) throws InterruptedException {
		if (!readindMode) {
			readindMode = true;
			readIntoBuffer();
		} else {
			DjvSystem.logError(Category.DESIGN, "Invoked while already in reading mode at " + DjvExceptionUtil.getCompressedTrace());
		}
	}

	@Override
	public void initiateWrite(FsmEvent evt) {
		enableReactorWrite();
	}

	@Override
	public synchronized void handleHandshake(FsmEvent evt) throws InterruptedException {
		try {
			// This is the same as that of a normal (non secured) connection
			if (channel.isConnectionPending()) {
				channel.finishConnect();
			} else if (!channel.isConnected()) {
				throw new ConnectException("not in connect pending state");
			}
			openningHanshake();
		} catch (ConnectException e) {
			DjvSystem.logWarning(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
			domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_FAILURE, this, e.getMessage()), true);
		} catch (java.io.IOException e) {
			DjvSystem.logWarning(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
			domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_FAILURE, this, e.getMessage()), true);
		}
	}

	@Override
	public void abortHandshake(FsmEvent evt) {
		synchronized (this) {
			setHandshakeAborted(true);
			setHandShakingMode(false);
			this.notifyAll();
			openFailed((FsmEvent) null);
		}

	}

	@Override
	public void onConnect() throws InterruptedException {
		domain.deregisterHandler(this, SelectionKey.OP_CONNECT);
		domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.HANDSHAKE, this), true);
	}

	@Override
	public void onRead() throws InterruptedException {
		synchronized (this) {
			try {
				if (null != channel) {
					inNetBuffer.compact();
					int bytesRead = channel.read(inNetBuffer);
					if (0 > bytesRead) {
						inNetBuffer.flip();

						// Probably end-of-stream, i.e. the other side closed its writer ...
						// ... trigger the transition on event READ_FAILURE
						throw new IOException("Read returned less than 0 byte, probably end of stream.");
					}

					inNetBuffer.flip();
				} else {
					throw new IOException("Channel is NULL, probably in the middle of shutting down");
				}

				if (isHandShakingMode()) {
					this.notifyAll(); // Tells the handshaking thread to continue
				} else {
					inAppBuffer.compact();
					int safety = 10;
					while (--safety > 0) {
						SSLEngineResult res = sslEngine.unwrap(inNetBuffer, inAppBuffer);

						if (res.getStatus() == SSLEngineResult.Status.CLOSED) {
							throw new SSLException("Session closed");
						} else if (res.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW) {
							// No more room to read in
							DjvSystem.logWarning(Category.DESIGN, "Data coming in faster than being processed");
							disableReactorRead();
							break;
						} else if (res.getStatus() != SSLEngineResult.Status.OK) {
							// Buffer underflow, done unwrapping
							break;
						}
					}
					inAppBuffer.flip();
					readIntoBuffer();
				}
			} catch (IOException e) {
				DjvSystem.logInfo(Category.DESIGN, "Closing channel due to " + e.getMessage());
				disableReactorRead();
				if (isHandShakingMode()) {
					setHandshakeAborted(true);
					AfxConnectionTLS.this.notifyAll();
				} else {
					domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.CLOSE, this), true);
				}
			}
		}
	}

	@Override
	public void onWrite() throws InterruptedException {
		synchronized (this) {
			try {
				if (!isHandShakingMode()) {
					if (m_WriteBuffer.hasRemaining()) {
						outNetBuffer.compact();
						SSLEngineResult res = sslEngine.wrap(m_WriteBuffer, outNetBuffer);
						outNetBuffer.flip();

						if ((res.getStatus() != SSLEngineResult.Status.OK) && (res.getStatus() != SSLEngineResult.Status.BUFFER_OVERFLOW)) {
							throw new SSLException("Wrap failed with " + res.getStatus());
						} else if (!m_WriteBuffer.hasRemaining()) {
							// Wrote the entire buffer, generate write complete event ...
							domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.WRITE_COMPLETE, this), true);
						}
					}
				}

				if (outNetBuffer.hasRemaining()) {
					if (0 > channel.write(outNetBuffer)) {
						throw new IOException("Write failed");
					}
				} else {
					// No more data to write
					disableReactorWrite();
				}

				if (isHandShakingMode()) {
					AfxConnectionTLS.this.notifyAll(); // Tells the handshaking thread to continue.
				}
			} catch (IOException e) {
				DjvSystem.logInfo(Category.DESIGN, "Channel closed due to " + e.getMessage());

				disableReactorWrite();

				if (isHandShakingMode()) {
					setHandshakeAborted(true);
					AfxConnectionTLS.this.notifyAll();
				} else {
					domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.CLOSE, this), true);
				}
			}
		}
	}

	private void readIntoBuffer() throws InterruptedException {
		if (readindMode) {
			int inputRemaining = inAppBuffer.remaining();
			int readRemaining = readBuffer.remaining();
			if (0 < readRemaining) {
				int bytes = (inputRemaining > readRemaining) ? readRemaining : inputRemaining;
				if (0 < bytes) {
					readBuffer.put(inAppBuffer.array(), inAppBuffer.arrayOffset() + inAppBuffer.position(), bytes);
					inAppBuffer.position(inAppBuffer.position() + bytes);
					if (!readBuffer.hasRemaining()) {
						readindMode = false;
						domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.READ_COMPLETE, this), true);
					}
				} else {
					// No more data in the network input buffer, need to read in some more
					enableReactorRead();
				}
			} else {
				readindMode = false;
				domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.READ_COMPLETE, this), true);
			}
		}
	}

	private void openningHanshake() {
		synchronized (this) {
			if (!isHandShakingMode()) {
				setHandShakingMode(true);
				setHandshakeDone(false);
				setHandshakeAborted(false);
				handshakeThread = new Thread(() -> {
					try {
						try {
							sslEngine.beginHandshake();
							int safety = 100;
							while ((--safety > 0) && (!isHandshakeAborted()) && (!isHandshakeDone())) {
								SSLEngineResult.HandshakeStatus stat = sslEngine.getHandshakeStatus();
								if (stat == SSLEngineResult.HandshakeStatus.NEED_TASK) {
									Runnable task = sslEngine.getDelegatedTask();
									if (null != task) {
										task.run();
									}
								} else if (stat == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
									synchronized (AfxConnectionTLS.this) {
										inAppBuffer.clear();
										SSLEngineResult res = sslEngine.unwrap(inNetBuffer, inAppBuffer);
										if (res.getStatus() == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
											enableReactorRead();
											AfxConnectionTLS.this.wait(1000);
										} else if (res.getStatus() == SSLEngineResult.Status.OK) {
											if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
												setHandshakeDone(true);
											}
										} else {
											throw new SSLException("Failed to wrap due to " + res.getStatus());
										}
									}
								} else if (stat == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
									synchronized (AfxConnectionTLS.this) {
										outNetBuffer.compact();
										SSLEngineResult res = sslEngine.wrap(inAppBuffer, outNetBuffer);
										outNetBuffer.flip();

										if ((res.getStatus() == SSLEngineResult.Status.OK) || (res.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW)) {
											if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
												setHandshakeDone(true);
											}
											enableReactorWrite();
											AfxConnectionTLS.this.wait(1000);
										} else {
											throw new SSLException("Failed to wrap due to " + res.getStatus());
										}
									}
								} else if (stat == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
									setHandshakeDone(true);
									break;
								} else if (stat == SSLEngineResult.HandshakeStatus.FINISHED) {
									setHandshakeDone(true);
									break;
								}
							}

							setHandShakingMode(false);

							inAppBuffer.clear();
							inAppBuffer.position(inAppBuffer.limit());

							if (safety == 0) {
								throw new SSLException("Safety break triggered");
							} else if (isHandshakeAborted()) {
								throw new SSLException("Handshake aborted");
							} else if (isHandshakeDone()) {
								domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_COMPLETE, AfxConnectionTLS.this), true);
							}
						} catch (SSLException | RuntimeException e) {
							DjvSystem.logWarning(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
							domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_FAILURE, AfxConnectionTLS.this,
								e.getMessage()), true);
						}
					} catch(InterruptedException e) {
					}
				});
				handshakeThread.start();
			} else {
				DjvSystem.logError(Category.DESIGN, "Already in handshaking mode");
			}
		}
	}

	private void closingHandshake() {
		synchronized (this) {
			if (!isHandShakingMode()) {
				setHandShakingMode(true);
				setHandshakeDone(false);
				setHandshakeAborted(false);
				handshakeThread = new Thread(() -> {
					try {
						try {
							sslEngine.closeOutbound();
							int safety = 10;
							while ((--safety > 0) && (!isHandshakeDone()) && (!isHandshakeAborted())) {
								if (!sslEngine.isOutboundDone()) {
									outNetBuffer.compact();
									SSLEngineResult res = sslEngine.wrap(inAppBuffer, outNetBuffer);
									outNetBuffer.flip();
									enableReactorWrite();
									AfxConnectionTLS.this.wait(100);
									if (res.getStatus() == SSLEngineResult.Status.OK) {
										if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
											break;
										}
									}
								} else if (!sslEngine.isInboundDone()) {
									inAppBuffer.clear();
									SSLEngineResult res = sslEngine.unwrap(inNetBuffer, inAppBuffer);
									if (res.getStatus() == SSLEngineResult.Status.OK) {
										if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
											break;
										}
									}
									enableReactorRead();
									AfxConnectionTLS.this.wait(100);
								} else {
									break;
								}
							}

							if (safety == 0) {
								throw new SSLException("Safety break activated");
							}
						} catch (RuntimeException | SSLException e) {
							DjvSystem.logWarning(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
						}
						
						setHandShakingMode(false);
						domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.CLOSE_COMPLETE, AfxConnectionTLS.this), true);
						disableReactorRead();
						disableReactorWrite();
						
						if (null != channel) {
							try {
								channel.close();
							} catch (IOException e) {
								DjvSystem.logError(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
							}
							channel = null;
						}
						if (null != connectionventHandler) {
							connectionventHandler.closed();
						}
						
						connectionventHandler = null;
					} catch(InterruptedException e) {
					}
				});
				handshakeThread.start();
			} else {
				DjvSystem.logError(Category.DESIGN, "Already in handshaking mode");
			}
		}
	}

	/**
	 * Determines whether the connection is in hand-shaking mode
	 *
	 * @return True if in hand-shaking mode, false otherwise
	 */
	private synchronized boolean isHandShakingMode() {
		return handShakingMode;
	}

	/**
	 * Specifies whether the connection is in hand-shaking mode
	 *
	 * @param value True if in hand-shaking mode, false otherwise
	 * @return This object
	 */
	private synchronized AfxConnectionTLS setHandShakingMode(boolean value) {
		this.handShakingMode = value;
		return this;
	}

	/**
	 * Determines whether hand-shaking is aborted
	 *
	 * @return True if hand-shaking is aborted, false otherwise
	 */
	private synchronized boolean isHandshakeAborted() {
		return handshakeAborted;
	}

	/**
	 * Specifies whether hand-shaking is aborted
	 *
	 * @param value The new value to be set
	 * @return This object
	 */
	private synchronized AfxConnectionTLS setHandshakeAborted(boolean value) {
		this.handshakeAborted = value;
		return this;
	}

	/**
	 * Determines whether hand-shaking is completed
	 *
	 * @return True if hand-shake is completed, false otherwise.
	 */
	private synchronized boolean isHandshakeDone() {
		return handshakeDone;
	}

	/**
	 * Specifies whether hand-shaking is completed
	 *
	 * @param value The new value to be set
	 * @return This object
	 */
	private synchronized AfxConnectionTLS setHandshakeDone(boolean value) {
		this.handshakeDone = value;
		return this;
	}

	private final ByteBuffer inNetBuffer;
	private final ByteBuffer inAppBuffer;
	private boolean handshakeAborted;
	private boolean handshakeDone;
	private boolean handShakingMode;
	private Thread handshakeThread;
	private boolean readindMode;
	private static SSLContext gSslContext;
}
