/* Generated by Together */

package org.dejavu.activefx;
import org.dejavu.fsm.FsmEvent;
import org.dejavu.util.DjvExceptionUtil;
import org.dejavu.util.DjvLogMsg.Category;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLSession;
import org.dejavu.util.DjvSystem;
import org.dejavu.netutil.DjvSocketSslFactory;
import java.net.ConnectException;


public class AfxConnectionTLS extends AfxConnectionTcp
{
	private final SSLEngine m_SslEngine;
	private final int m_MinAppBufferSize;
	private final int m_MinNetBufferSize;
	private final ByteBuffer m_OutNetBuffer;

	public AfxConnectionTLS(AfxDomain domain) throws SSLException
	{
		super(domain);

		if(null == s_SslContext)
		{
			s_SslContext = DjvSocketSslFactory.getInstance().getSslContext();
		}

		m_SslEngine = s_SslContext.createSSLEngine();
		m_SslEngine.setUseClientMode(true);

		SSLSession session = m_SslEngine.getSession();
		m_MinAppBufferSize = session.getApplicationBufferSize();
		m_MinNetBufferSize = session.getPacketBufferSize();

		m_OutNetBuffer = ByteBuffer.allocateDirect(m_MinNetBufferSize);
		m_OutNetBuffer.position(m_OutNetBuffer.limit()); // Empty buffer

		m_InNetBuffer = ByteBuffer.allocateDirect(m_MinNetBufferSize);
		m_InNetBuffer.position(m_InNetBuffer.limit()); // Empty buffer

		// The reason we have to add some extra room in here is that unwrap
		// looks for at least m_MinAppBufferSize remaining on the destination
		// buffer before proceeding, which is completely stupid
		m_InAppBuffer = ByteBuffer.allocate(m_MinAppBufferSize + 10240);
		m_InAppBuffer.position(m_InAppBuffer.limit()); // Empty buffer
	}

	@Override
	public int getConnectionType()
	{
		return AfxConnection.AFX_CONNECTION_TLS;
	}

	@Override
	public void initiateClose(FsmEvent evt)
	{
		closingHandshake();
	}

	@Override
	public synchronized void initiateRead(FsmEvent evt)
	{
		if(!m_ReadindMode)
		{
			m_ReadindMode = true;
			readIntoBuffer ();
		}
		else
		{
			DjvSystem.logError(Category.DESIGN, "Invoked while already in reading mode at " + DjvExceptionUtil.getCompressedTrace());
		}
	}

	@Override
	public void initiateWrite(FsmEvent evt)
	{
		enableReactorWrite();
	}

	@Override
	public synchronized void handleHandshake(FsmEvent evt)
	{
		try
		{
			// This is the same as that of a normal (non secured) connection
			if(channel.isConnectionPending())
			{
				channel.finishConnect();
			}
			else if(!channel.isConnected())
			{
				throw new ConnectException("not in connect pending state");
			}
			openningHanshake ();
		}
		catch(ConnectException e)
		{
			DjvSystem.logWarning(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
			domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_FAILURE, this, e.getMessage()), true);
		}
		catch(java.io.IOException e)
		{
			DjvSystem.logWarning(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
			domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_FAILURE, this, e.getMessage()), true);
		}
	}

	@Override
	public void abortHandshake(FsmEvent evt)
	{
		synchronized(this)
		{
			setHandshakeAborted(true);
			setHandShakingMode(false);
			AfxConnectionTLS.this.notifyAll();
			openFailed((FsmEvent)null);
		}

	}

	@Override
	public void onConnect()
	{
		domain.deregisterHandler(this, SelectionKey.OP_CONNECT);
		domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.HANDSHAKE, this), true);
	}

	@Override
	public void onRead()
	{
		synchronized(this)
		{
			try
			{
				if(null != channel)
				{
					m_InNetBuffer.compact();
					int bytesRead = channel.read(m_InNetBuffer);
					if(0 > bytesRead)
					{
						m_InNetBuffer.flip();

						// Probably end-of-stream, i.e. the other side closed its writer ...
						// ... trigger the transition on event READ_FAILURE
						throw new IOException("Read returned less than 0 byte, probably end of stream.");
					}

					m_InNetBuffer.flip();
				}
				else
					throw new IOException("Channel is NULL, probably in the middle of shutting down");

				if(isHandShakingMode())
				{
					AfxConnectionTLS.this.notifyAll(); // Tells the handshaking thread to continue
				}
				else
				{
					m_InAppBuffer.compact();
					int safety = 10;
					while(--safety > 0)
					{
						SSLEngineResult res = m_SslEngine.unwrap(m_InNetBuffer, m_InAppBuffer);
	
						if(res.getStatus() == SSLEngineResult.Status.CLOSED)
						{
							throw new SSLException("Session closed");
						}
						else if(res.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW)
						{
							// No more room to read in
							DjvSystem.logWarning(Category.DESIGN, "Data coming in faster than being processed");
							disableReactorRead();
							break;
						}
						else if(res.getStatus() != SSLEngineResult.Status.OK)
						{
							// Buffer underflow, done unwrapping
							break;
						}
					}
					m_InAppBuffer.flip();
					readIntoBuffer ();
				}
			}
			catch(Exception e)
			{
				DjvSystem.logInfo(Category.DESIGN, "Closing channel due to " + e.getMessage());
				disableReactorRead();
				if(isHandShakingMode())
				{
					setHandshakeAborted(true);
					AfxConnectionTLS.this.notifyAll();
				}
				else
					domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.CLOSE, this), true);
			}
		}
	}

	@Override
	public void onWrite()
	{
		synchronized(this)
		{
			try
			{
				if(!isHandShakingMode())
				{
					if(m_WriteBuffer.hasRemaining())
					{
						m_OutNetBuffer.compact();
						SSLEngineResult res = m_SslEngine.wrap(m_WriteBuffer, m_OutNetBuffer);
						m_OutNetBuffer.flip();

						if((res.getStatus() != SSLEngineResult.Status.OK)&&(res.getStatus() != SSLEngineResult.Status.BUFFER_OVERFLOW))
						{
							throw new SSLException("Wrap failed with " + res.getStatus());
						}
						else if(!m_WriteBuffer.hasRemaining())
						{
							// Wrote the entire buffer, generate write complete event ...
							domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.WRITE_COMPLETE, this), true);
						}
					}
				}
				
				if(m_OutNetBuffer.hasRemaining())
				{
					if(0 > channel.write(m_OutNetBuffer))
					{
						throw new IOException("Write failed");
					}
				}
				else
				{
					// No more data to write
					disableReactorWrite();
				}

				if(isHandShakingMode())
				{
					AfxConnectionTLS.this.notifyAll(); // Tells the handshaking thread to continue.
				}
			}
			catch(Exception e)
			{
				DjvSystem.logInfo(Category.DESIGN, "Channel closed due to " + e.getMessage());

				disableReactorWrite();

				if(isHandShakingMode())
				{
					setHandshakeAborted(true);
					AfxConnectionTLS.this.notifyAll();
				}
				else
					domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.CLOSE, this), true);
			}
		}
	}

	private void readIntoBuffer()
	{
		if(m_ReadindMode)
		{
			int inputRemaining = m_InAppBuffer.remaining();
			int readRemaining = readBuffer.remaining();
			if(0 < readRemaining)
			{
				int bytes = (inputRemaining > readRemaining)?readRemaining:inputRemaining;
				if(0 < bytes)
				{
					readBuffer.put(m_InAppBuffer.array(), m_InAppBuffer.arrayOffset() + m_InAppBuffer.position(), bytes);
					m_InAppBuffer.position(m_InAppBuffer.position() + bytes);
					if(!readBuffer.hasRemaining())
					{
						m_ReadindMode = false;
						domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.READ_COMPLETE, this), true);
					}
				}
				else
				{
					// No more data in the network input buffer, need to read in some more
					enableReactorRead();
				}
			}
			else
			{
				m_ReadindMode = false;
				domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.READ_COMPLETE, this), true);
			}
		}
	}

	private void openningHanshake()
	{
		synchronized(this) {
			if(!isHandShakingMode())
			{
				setHandShakingMode(true);
				setHandshakeDone(false);
				setHandshakeAborted(false);
				m_HandshakeThread = new Thread(new Runnable()
				{
					@Override
					public void run()
					{
						try
						{
							m_SslEngine.beginHandshake();
							int safety = 100;
							while((--safety > 0)&&(!isHandshakeAborted())&&(!isHandshakeDone()))
							{
								SSLEngineResult.HandshakeStatus stat = m_SslEngine.getHandshakeStatus();
								if(stat == SSLEngineResult.HandshakeStatus.NEED_TASK)
								{
									Runnable task = m_SslEngine.getDelegatedTask();
									if(null != task)
										task.run();
								}
								else if(stat == SSLEngineResult.HandshakeStatus.NEED_UNWRAP)
								{
									synchronized(AfxConnectionTLS.this)
									{
										m_InAppBuffer.clear();
										SSLEngineResult res = m_SslEngine.unwrap(m_InNetBuffer, m_InAppBuffer);
										if(res.getStatus() == SSLEngineResult.Status.BUFFER_UNDERFLOW)
										{
											enableReactorRead();
											AfxConnectionTLS.this.wait(1000);
										}
										else if(res.getStatus() == SSLEngineResult.Status.OK)
										{
											if(res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED)
											{
												setHandshakeDone(true);
											}
										}
										else
										{
											throw new SSLException("Failed to wrap due to " + res.getStatus());
										}
									}
								}
								else if(stat == SSLEngineResult.HandshakeStatus.NEED_WRAP)
								{
									synchronized(AfxConnectionTLS.this)
									{
										m_OutNetBuffer.compact();
										SSLEngineResult res = m_SslEngine.wrap(m_InAppBuffer, m_OutNetBuffer);
										m_OutNetBuffer.flip();

										if((res.getStatus() == SSLEngineResult.Status.OK)||(res.getStatus() == SSLEngineResult.Status.BUFFER_OVERFLOW))
										{
											if(res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED)
											{
												setHandshakeDone(true);
											}
											enableReactorWrite();
											AfxConnectionTLS.this.wait(1000);
										}
										else
											throw new SSLException("Failed to wrap due to " + res.getStatus());
									}
								}
								else if(stat == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING)
								{
									setHandshakeDone(true);
									break;
								}
								else if(stat == SSLEngineResult.HandshakeStatus.FINISHED)
								{
									setHandshakeDone(true);
									break;
								}
							}
						
							setHandShakingMode(false);

							m_InAppBuffer.clear();
							m_InAppBuffer.position(m_InAppBuffer.limit());

							if(safety == 0)
								throw new SSLException("Safety break triggered");
							else if(isHandshakeAborted())
								throw new SSLException("Handshake aborted");
							else if(isHandshakeDone())
								domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_COMPLETE, AfxConnectionTLS.this), true);
						}
						catch(SSLException e)
						{
							DjvSystem.logWarning(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
							domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_FAILURE, AfxConnectionTLS.this,
								e.getMessage()), true);
						}
						catch(RuntimeException e)
						{
							DjvSystem.logError(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
							domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.OPEN_FAILURE, AfxConnectionTLS.this,
								e.getMessage()), true);
						}
						catch(InterruptedException ex)
						{
						}
					}
				});
				m_HandshakeThread.start();
			}
			else
			{
				DjvSystem.logError(Category.DESIGN, "Already in handshaking mode");
			}
		}
	}

	private void closingHandshake()
	{
		synchronized(this) {
			if(!isHandShakingMode())
			{
				setHandShakingMode(true);
				setHandshakeDone(false);
				setHandshakeAborted(false);
				m_HandshakeThread = new Thread(new Runnable()
				{
					public void run()
					{
						try
						{
							synchronized(AfxConnectionTLS.this)
							{
								m_SslEngine.closeOutbound();
								int safety = 10;
								while((--safety > 0)&&(!isHandshakeDone())&&(!isHandshakeAborted()))
								{
									if(!m_SslEngine.isOutboundDone())
									{
										m_OutNetBuffer.compact();
										SSLEngineResult res = m_SslEngine.wrap(m_InAppBuffer, m_OutNetBuffer);
										m_OutNetBuffer.flip();
										enableReactorWrite();
										AfxConnectionTLS.this.wait(100);
										if(res.getStatus() == SSLEngineResult.Status.OK)
										{
											if(res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED)
											{
												break;
											}
										}
									}
									else if(!m_SslEngine.isInboundDone())
									{
										m_InAppBuffer.clear();
										SSLEngineResult res = m_SslEngine.unwrap(m_InNetBuffer, m_InAppBuffer);
										if(res.getStatus() == SSLEngineResult.Status.OK)
										{
											if(res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED)
											{
												break;
											}
										}
										enableReactorRead();
										AfxConnectionTLS.this.wait(100);
									}
									else
										break;
								}

								if(safety == 0)
									throw new SSLException("Safety break activated");
							}
						}
						catch(RuntimeException e)
						{
							DjvSystem.logError(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
						}
						catch(SSLException ex)
						{
							DjvSystem.logWarning(Category.DESIGN, DjvExceptionUtil.simpleTrace(ex));
						}
						catch(InterruptedException ex)
						{
						}

						setHandShakingMode(false);
						domain.dispatchEvent(new AfxFsmEvent(AfxFsmEvent.CLOSE_COMPLETE, AfxConnectionTLS.this), true);
						disableReactorRead();
						disableReactorWrite();

						if(null != channel)
						{
							try
							{
								channel.close();
							}
							catch(Exception e)
							{
								DjvSystem.logError(Category.DESIGN, DjvExceptionUtil.simpleTrace(e));
							}
							channel = null;
						}
						if(null != connectionventHandler)
							connectionventHandler.closed();

						connectionventHandler = null;
					}
				});
				m_HandshakeThread.start();
			}
			else
			{
				DjvSystem.logError(Category.DESIGN, "Already in handshaking mode");
			}
		}
	}

	/**
	 * Determines whether the connection is in hand-shaking mode
	 * @return True if in hand-shaking mode, false otherwise
	 */
	private synchronized boolean isHandShakingMode()
	{
		return m_HandShakingMode;
	}
	
	/**
	 * Specifies whether the connection is in hand-shaking mode
	 * @param value True if in hand-shaking mode, false otherwise
	 * @return This object
	 */
	private synchronized AfxConnectionTLS setHandShakingMode(boolean value)
	{
		this.m_HandShakingMode = value;
		return this;
	}

	/**
	 * Determines whether hand-shaking is aborted
	 * @return True if hand-shaking is aborted, false otherwise
	 */
	private synchronized boolean isHandshakeAborted()
	{
		return m_HandshakeAborted;
	}

	/**
	 * Specifies whether hand-shaking is aborted
	 * @param value The new value to be set
	 * @return This object
	 */
	private synchronized AfxConnectionTLS setHandshakeAborted(boolean value)
	{
		this.m_HandshakeAborted = value;
		return this;
	}

	/**
	 * Determines whether hand-shaking is completed
	 * @return True if hand-shake is completed, false otherwise.
	 */
	private synchronized boolean isHandshakeDone()
	{
		return m_HandshakeDone;
	}

	/**
	 * Specifies whether hand-shaking is completed
	 * @param value The new value to be set
	 * @return This object
	 */
	private synchronized AfxConnectionTLS setHandshakeDone(boolean value)
	{
		this.m_HandshakeDone = value;
		return this;
	}

	private final ByteBuffer m_InNetBuffer;
	private final ByteBuffer m_InAppBuffer;
	private boolean m_HandshakeAborted;
	private boolean m_HandshakeDone;
	private boolean m_HandShakingMode;
	private Thread m_HandshakeThread;
	private boolean m_ReadindMode;
	private static SSLContext s_SslContext;
}
