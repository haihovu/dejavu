/* Generated by Together */
package org.dejavu.util;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * The default log handler implementation. Basically queues up the log messages
 * and prints them to the stdout, using a separate thread.
 */
public class DjvLogHandlerDefault implements DjvLogHandler, Runnable {

	/**
	 * Creates a new instance of the default log handler.
	 *
	 * @param queueSize Size of the log queue.
	 */
	public DjvLogHandlerDefault(int queueSize) {
		logQueue = new LinkedBlockingQueue<>(queueSize);
	}

	@Override
	public synchronized void start() {
		stop();
		setRunFlag(true);
		workerThread = new Thread(this, "SysLog");
		workerThread.start();
	}

	@Override
	public synchronized void stop() {
		setRunFlag(false);
		if (null != workerThread) {
			workerThread.interrupt();

			// Wait for thread to terminate
			try {
				workerThread.join(10000);
			} catch (InterruptedException ex) {
			}

			workerThread = null;
		}
	}

	@Override
	public DjvLogMsg logMsg(DjvLogMsg.Category category, int severity, Class<?> origClass, String origMethod, String message) {
		return logMsg(new DjvLogMsg(category, severity, origClass, origMethod, message));
	}

	@Override
	public DjvLogMsg logMsg(DjvLogMsg msg) {
		try {
			if (!logQueue.offer(msg, 1, TimeUnit.SECONDS)) {
				System.err.println("ERROR - " + getClass() + ".logMsg - Queue full");
			}
		} catch (InterruptedException ex) {
		}
		return msg;
	}

	@Override
	public void setLogFilterLevel(int logLevel) {
		logFilterLevel = logLevel;
	}

	@Override
	public int getLogFilterLevel() {
		return logFilterLevel;
	}

	@Override
	public void run() {
		try {
			while (isRunFlag()) {
				DjvLogMsg log = logQueue.poll(2, TimeUnit.SECONDS);
				if (log == null) {
					continue;
				}
				System.err.println(log.tsToString() + " - " + log.toString());
			}
		} catch (InterruptedException e) {
		}

		// Flush out the rest of the log msgs
		while (true) {
			DjvLogMsg log = logQueue.poll();
			if (null == log) {
				// Log queue is now empty, exit thread
				break;
			}
			System.err.println(log.tsToString() + " - " + log.toString());
		}
	}

	/**
	 * Determines whether the run flag is true
	 *
	 * @return The current state of the run flag
	 */
	private synchronized boolean isRunFlag() {
		return runFlag;
	}

	/**
	 * Specifies the run flag value
	 *
	 * @param newValue The new run flag value
	 * @return This object
	 */
	private synchronized DjvLogHandlerDefault setRunFlag(boolean newValue) {
		this.runFlag = newValue;
		return this;
	}

	private Thread workerThread;
	private boolean runFlag;
	private final LinkedBlockingQueue<DjvLogMsg> logQueue;
	private static volatile int logFilterLevel = 2; // Default log level is Error & Warning
}
