/* Generated by Together */
package org.dejavu.util;

import java.util.Timer;
import java.util.TimerTask;

/**
 * <p>
 * The base implementation of a watchdog system. In this system, there is the
 * concept of one or more watchdogs that monitors the status of a number of
 * components. The components to be monitored are registered with their
 * respective watchdogs with the following attributes:
 * <ul>
 * <li>Name - Name of the component.</li>
 * <li>Period - Intervals that the component must report status to the
 * watchdog.</li>
 * <li>Response - Instruction as to what to do if the component fails, this is a
 * piece of runnable logic.</li>
 * </ul>
 * </p>
 * <p>
 * The monitored components must report their status with their watchdogs at
 * regular intervals (as specified in the registration process). The watchdogs
 * periodically check to see if all their monitored components have reported
 * their status at the indicated intervals. If a component fails to report its
 * status in a timely manner (the watchdog gives the components double the
 * registered intervals to report their status), the watchdog will execute the
 * response that was registered with this component. This way the watchdog
 * leaves it to the monitored components to determine what is to be done in
 * cases of failures.
 * </p>
 */
public class DjvWatchDog extends TimerTask {

	/**
	 * Component status. Used for status reporting.
	 */
	public enum Status {
		WD_NORMAL, WD_FAILED
	}

	/**
	 * Creates a new watchdog instance.
	 *
	 * @param name Name of the watchdog.
	 * @param capacity The capacity of the watchdog, i.e. how many monitors it
	 * can manage.
	 */
	public DjvWatchDog(String name, int capacity) {
		monitorRepository = new MonitorInfo[capacity];
		maxIndex = 0;
		wdName = name;
	}

	/**
	 * Starts the watchdog.
	 *
	 * @param timeResolution How often does the watchdog check the monitored
	 * components, in milliseconds.
	 */
	public synchronized void start(int timeResolution) {
		if ((timeResolution > 0) && (null == timer)) {
			this.timeResolution = timeResolution;
			timer = new Timer(wdName);
			timer.scheduleAtFixedRate(this, 0, timeResolution);
		}
	}

	/**
	 * Stops the watchdog. Note that due to its implementation, once stopped a
	 * watchdog cannot be restarted.
	 */
	public synchronized void stop() {
		if (null != timer) {
			cancel();
			timer.cancel();
		}
	}

	/**
	 * Reports the status of a component.
	 *
	 * @param key The key identifying the status of the component.
	 * @param status The status of the component. If the status reported is
	 * WD_FAILED, the failure response will be executed.
	 * @return Whether the status reporting was successful.
	 */
	public boolean reportStatus(int key, Status status) {
		if ((key > -1) && (key < maxIndex)) {
			MonitorInfo monitor = getMonitorInfo(key);
			if (null != monitor) {
				if (DjvSystem.diagnosticEnabled()) {
					DjvSystem.logInfo(DjvLogMsg.Category.DESIGN,
							"Reporting " + status + " for " + monitor);
				}

				synchronized (monitor) {
					if (status == Status.WD_NORMAL) {
						monitor.counter = monitor.period;
						monitor.onProbation = false;
					} else if (status == Status.WD_FAILED) {
						executeResponse(monitor);
					}
					return true;
				}
			} else {
				DjvSystem.logWarning(DjvLogMsg.Category.DESIGN,
						"No monitor for key: " + key);
			}
		} else {
			DjvSystem.logWarning(DjvLogMsg.Category.DESIGN,
					"Invalid key: " + key);
		}

		return false;
	}
	private MonitorInfo getMonitorInfo(int key) {
		synchronized(monitorRepository) {
			return key < monitorRepository.length ? monitorRepository[key] : null;
		}
	}
	/**
	 * Registers a component with the watchdog for monitoring.
	 *
	 *
	 * @param name Name of the component.
	 * @param wdPeriod Intervals of status report, in milliseconds.
	 * @param failureResponse The failureResponse in case of component failure.
	 * If specified, the watchdog will execute the given logic if a failure is
	 * detected.
	 * @return An integer key to allow the client to report its status later.
	 */
	public int registerComponent(String name, int wdPeriod, Runnable failureResponse) {
		synchronized(monitorRepository) {
			for (int i = 0; i < maxIndex; ++i) {
				if (monitorRepository[i] == null) {
					monitorRepository[i] = new MonitorInfo(name, wdPeriod, failureResponse);
					return i;
				}
			}

			if (maxIndex < monitorRepository.length) {
				int index = maxIndex++;
				monitorRepository[index] = new MonitorInfo(name, wdPeriod, failureResponse);

				return index;
			}
		}
		DjvSystem.logError(DjvLogMsg.Category.DESIGN,
				"Monitor capacity (" + monitorRepository.length + ") exceeded while registering " + name);

		return -1;
	}

	/**
	 * Deregisters a component with the watchdog.
	 *
	 * @param key
	 */
	public void deregisterComponent(int key) {
		synchronized(monitorRepository) {
			if ((key > -1) && (key < maxIndex)) {
				if (monitorRepository[key] != null) {
					DjvSystem.logWarning(DjvLogMsg.Category.DESIGN,
							"Deregistering " + monitorRepository[key]);

					monitorRepository[key] = null;
				}
			}
		}
	}

	@SuppressWarnings({"NestedAssignment", "NestedSynchronizedStatement"})
	@Override
	public void run() {
		synchronized (monitorRepository) {
			for (int i = 0; i < maxIndex; ++i) {
				MonitorInfo monitor = monitorRepository[i];
				if (null != monitor) {
					synchronized (monitor) {
						if ((monitor.counter -= timeResolution) > 0) {
							// This component is OK, go to the next
							continue;
						}

						// Component missed report
						if (!monitor.onProbation) {
							// Give the component one more chance to report its status
							monitor.onProbation = true;
							monitor.counter = monitor.period;

							if (DjvSystem.getLogLevel() > 1) {
								DjvSystem.logInfo(DjvLogMsg.Category.DESIGN,
										"Placing " + monitor + " on probation");
							}
						} else {
							DjvSystem.logWarning(DjvLogMsg.Category.DESIGN,
									"Failure detected in component " + monitor);

							// Stop monitoring this particular component
							monitorRepository[i] = null;
							executeResponse(monitor);
						}
					}
				}
			}
		}
	}

	@Override
	public String toString() {
		return wdName;
	}

	/**
	 * Executes the response logic for a monitor, using a background thread.
	 * @param monitor The target monitor.
	 */
	private void executeResponse(MonitorInfo monitor) {
		if (monitor.response != null) {
			new Thread(monitor.response, "wd" + monitor.name).start();
		}
	}

	private static class MonitorInfo {

		final int period;
		final String name;
		final Runnable response;
		int counter;
		boolean onProbation;

		MonitorInfo(String name, int period, Runnable response) {
			this.name = name;
			this.period = period;
			this.response = response;
		}

		@Override
		public String toString() {
			return "MonitorInfo{" + "period=" + period + ", name=" + name + ", response=" + response + ", counter=" + counter + ", onProbation=" + onProbation + '}';
		}
		
	}

	/**
	 * The repository of registered components.
	 */
	private final MonitorInfo[] monitorRepository;
	/**
	 * The maximum index into the m_MonitorRepository array indicating the upper
	 * limit of registered components.
	 */
	private volatile int maxIndex;
	/**
	 * Timer used to drive the watchdog monitoring process.
	 */
	private Timer timer;
	/**
	 * Name of the watchdog, note that there may be multiple instances of the
	 * watchdogs running in an application.
	 */
	private final String wdName;
	/**
	 * Resolution of the watchdog timer, in milliseconds.
	 */
	private int timeResolution;
}
